!SESSION 2022-09-28 21:07:56.918 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-09-28 21:08:23.720
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-28 21:08:23.720
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@434d001d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36453773,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-28 21:08:23.720
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4db16677,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6abb44cb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2022-09-28 21:52:29.558 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2022-09-28 21:52:38.452
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.osgi 4 0 2022-09-28 21:52:44.359
!MESSAGE Application error
!STACK 1
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4944)
	at org.eclipse.swt.SWT.error(SWT.java:4833)
	at org.eclipse.swt.SWT.error(SWT.java:4804)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:450)
	at org.eclipse.swt.widgets.Control.createHandle(Control.java:718)
	at org.eclipse.swt.widgets.Scrollable.createHandle(Scrollable.java:145)
	at org.eclipse.swt.widgets.Composite.createHandle(Composite.java:294)
	at org.eclipse.swt.widgets.Control.createWidget(Control.java:746)
	at org.eclipse.swt.widgets.Scrollable.createWidget(Scrollable.java:160)
	at org.eclipse.swt.widgets.Control.<init>(Control.java:116)
	at org.eclipse.swt.widgets.Scrollable.<init>(Scrollable.java:85)
	at org.eclipse.swt.widgets.Composite.<init>(Composite.java:99)
	at org.eclipse.ui.splash.BasicSplashHandler.getBundleProgressMonitor(BasicSplashHandler.java:136)
	at org.eclipse.ui.splash.BasicSplashHandler.getContent(BasicSplashHandler.java:222)
	at org.eclipse.ui.internal.splash.EclipseSplashHandler.init(EclipseSplashHandler.java:99)
	at org.eclipse.ui.internal.Workbench$3.run(Workbench.java:814)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.createSplashWrapper(Workbench.java:828)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:612)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-09-28 22:03:27.681 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2022-09-28 22:03:31.774
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2022-09-28 22:03:33.940
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-28 22:03:33.940
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7096d451,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7816454d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-28 22:03:33.940
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@67d180e4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54e18a46,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2022-09-30 18:53:17.292 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-09-30 18:55:51.426
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-30 18:55:51.426
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3a589eed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5807ea46,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-30 18:55:51.427
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@305289b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ee68377,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-01 11:46:29.672
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package Conflict;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.Random;

import javax.swing.DefaultListModel;
import javax.swing.JFrame;
import javax.swing.JScrollPane;

import Company.Company;
import CreateGame.SetupWindow;
import HexGrid.HexGrid;
import HexGrid.HexGrid.DeployedUnit;
import Hexes.Hex;
import Hexes.HexWindow;
import Items.PersonalShield;
import Trooper.Trooper;
import Unit.Unit;
import UtilityClasses.HexGridUtility;

import javax.swing.JList;
import javax.swing.JButton;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import java.lang.reflect.Array;

import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.JLabel;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.Toolkit;

import javax.swing.LayoutStyle.ComponentPlacement;

import Actions.Spot;
import Artillery.FireMission;

import javax.swing.JComboBox;
import javax.swing.DefaultComboBoxModel;
import java.awt.event.ItemListener;
import java.awt.event.ItemEvent;
import javax.swing.JSpinner;
import javax.swing.SwingWorker;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

public class GameWindow implements Serializable {
	public static int hexSize = 20;
	public ArrayList<Company> companies;
	public ArrayList<Unit> initiativeOrder = new ArrayList<Unit>();
	public Game game;
	public String visibility = "Good Visibility";
	public ArrayList<Hex> hexes = new ArrayList<Hex>();
	public CloseQuartersBattle cqb = new CloseQuartersBattle(this);
	public ConflictLog conflictLog;
	public static GameWindow gameWindow;

	public SetupWindow setupWindow;
	public JList listIniativeOrder;
	public JFrame f = null;
	public int activeUnit = 0;
	private JLabel lblActiveUnit;
	private JLabel lblRound;
	private JLabel lblPhase;
	private JLabel lblActions;
	public JComboBox comboBoxVisibility;
	private JButton btnStartingSpotTest;
	private JSpinner spinnerInitMod;
	private JComboBox comboBoxInitModSide;
	private JComboBox comboBoxValueMod;
	private JSpinner spinnerValueMod;
	private JSpinner spinnerActiveUnit;
	public HexGrid hexGrid;
	public boolean cqbWindowOpen = false;
	public OpenUnit currentlyOpenUnit;
	private JSpinner spinnerHexSize;
	public int hexCols; 
	public int hexRows; 
	

	/**
	 * Launch the application.
	 */
	public GameWindow(ArrayList<Company> companiesFromSetupWindow, SetupWindow setupWindow, Game game,
			boolean openUnit, int hexRows, int hexCols) {
		this.hexCols = hexCols;
		this.hexRows = hexRows; 
		this.game = game;
		this.gameWindow = this;
		this.conflictLog = new ConflictLog();
		this.setupWindow = setupWindow;
		this.companies = companiesFromSetupWindow;
		conflictLog.addNewLine("     Round: " + game.getRound() + " Phase: " + game.getPhase());
		f = new JFrame("Conflict");
		f.setSize(600, 545);

		// Get the screen size
		Toolkit toolkit = Toolkit.getDefaultToolkit();
		Dimension screenSize = toolkit.getScreenSize();
		// Calculate the frame location
		int x = (screenSize.width - f.getWidth()) / 2;
		int y = (screenSize.height - f.getHeight()) / 2;

		// Set the new frame location
		f.setLocation(x, y);

		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent ev) {
				// frame.dispose();
			}
		});

		JScrollPane scrollPane = new JScrollPane();
		scrollPane.setBounds(10, 196, 564, 302);

		listIniativeOrder = new JList();
		listIniativeOrder.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				Unit unit = initiativeOrder.get(listIniativeOrder.getSelectedIndex());
				// System.out.println("Open unit moral: "+unit.moral);

				if (currentlyOpenUnit != null)
					currentlyOpenUnit.f.dispose();
				currentlyOpenUnit = new OpenUnit(unit, gameWindow, listIniativeOrder.getSelectedIndex());
			}
		});
		scrollPane.setViewportView(listIniativeOrder);

		JButton btnRefreshUnits = new JButton("Add New Units");
		btnRefreshUnits.setBounds(10, 39, 128, 25);
		btnRefreshUnits.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				refreshUnits();

			}
		});

		lblActiveUnit = new JLabel("Active Unit: ");
		lblActiveUnit.setBounds(328, 11, 233, 17);
		lblActiveUnit.setFont(new Font("Calibri", Font.BOLD, 13));

		lblRound = new JLabel("Round:");
		lblRound.setBounds(10, 11, 113, 17);
		lblRound.setFont(new Font("Calibri", Font.BOLD, 13));

		lblPhase = new JLabel("Phase:");
		lblPhase.setBounds(129, 11, 113, 17);
		lblPhase.setFont(new Font("Calibri", Font.BOLD, 13));

		lblActions = new JLabel("Actions:");
		lblActions.setBounds(248, 11, 113, 17);
		lblActions.setFont(new Font("Calibri", Font.BOLD, 13));

		JButton btnD = new JButton("D100");
		btnD.setBounds(148, 40, 69, 23);
		btnD.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {
				Random rand = new Random();
				int roll = rand.nextInt(100) + 1;
				conflictLog.addNewLine("Roll: " + roll);
			}
		});

		comboBoxVisibility = new JComboBox();
		comboBoxVisibility.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {

				visibility = comboBoxVisibility.getSelectedItem().toString();
				game.setDaylightCondition(visibility);

			}
		});
		comboBoxVisibility.setBounds(219, 162, 193, 23);
		comboBoxVisibility.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent arg0) {

			}
		});
		comboBoxVisibility.setModel(new DefaultComboBoxModel(
				new String[] { "Good Visibility", "Dusk", "Night - Full Moon ", "Night - Half Moon", "Night - No Moon",
						"Smoke/Fog/Haze/Overcast", "Dusk - Smoke/Fog/Haze/Overcast", "Night - Smoke/Fog/Haze/Overcast",
						"No Visibility - Heavy Fog - White Out" }));

		JLabel lblVisibility = new JLabel("Visibility:");
		lblVisibility.setBounds(152, 165, 59, 17);
		lblVisibility.setFont(new Font("Calibri", Font.BOLD, 13));

		btnStartingSpotTest = new JButton("General Spot Test");
		btnStartingSpotTest.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
			}
		});
		btnStartingSpotTest.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {

						// System.out.println("Spot1");
						spotCycle();
						// System.out.println("Spot2");
						return null;
					}

					@Override
					protected void done() {

						// System.out.println("Done");
						gameWindow.conflictLog.addQueuedText();
						gameWindow.conflictLog.addNewLine("General Spot Test Completed");
					}

				};

				worker.execute();

			}
		});
		btnStartingSpotTest.setBounds(444, 162, 128, 23);
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

		setInitiativeOrder(companies);
		refreshInitiativeOrder();

		// Sets next active unit
		listIniativeOrder.setSelectedIndex(activeUnit);
		f.getContentPane().setLayout(null);
		f.getContentPane().add(btnStartingSpotTest);
		f.getContentPane().add(scrollPane);
		f.getContentPane().add(lblVisibility);
		f.getContentPane().add(comboBoxVisibility);
		f.getContentPane().add(btnRefreshUnits);
		f.getContentPane().add(lblRound);
		f.getContentPane().add(lblPhase);
		f.getContentPane().add(lblActions);
		f.getContentPane().add(lblActiveUnit);
		f.getContentPane().add(btnD);

		JButton btnNewButton = new JButton("Roll Init Order");
		btnNewButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				setInitiativeOrder(companies);

				for (Unit unit : initiativeOrder) {
					if (unit.side.equals(comboBoxInitModSide.getSelectedItem()))
						unit.initiative += (int) spinnerInitMod.getValue();
				}

				rollInitiativeOrder();
				refreshInitiativeOrder();
			}
		});
		btnNewButton.setBounds(256, 70, 128, 23);
		f.getContentPane().add(btnNewButton);

		JLabel lblInitMod = new JLabel("Init Mod:");
		lblInitMod.setFont(new Font("Calibri", Font.BOLD, 13));
		lblInitMod.setBounds(133, 73, 59, 17);
		f.getContentPane().add(lblInitMod);

		spinnerInitMod = new JSpinner();
		spinnerInitMod.setBounds(202, 71, 44, 20);
		f.getContentPane().add(spinnerInitMod);

		comboBoxInitModSide = new JComboBox();
		comboBoxInitModSide.setModel(new DefaultComboBoxModel(new String[] { "BLUFOR", "OPFOR", "IND" }));
		comboBoxInitModSide.setSelectedIndex(0);
		comboBoxInitModSide.setBounds(48, 68, 75, 23);
		f.getContentPane().add(comboBoxInitModSide);

		JLabel lblSide = new JLabel("Side:");
		lblSide.setFont(new Font("Calibri", Font.BOLD, 13));
		lblSide.setBounds(10, 72, 59, 17);
		f.getContentPane().add(lblSide);

		JLabel lblValueMod = new JLabel("Stat Mod:");
		lblValueMod.setFont(new Font("Calibri", Font.BOLD, 13));
		lblValueMod.setBounds(10, 104, 59, 17);
		f.getContentPane().add(lblValueMod);

		JButton btnNewButton_1 = new JButton("Org.");
		btnNewButton_1.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.organization + (int) spinnerValueMod.getValue() > 100) {
							unit.organization = 100;
						} else {
							unit.organization += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnNewButton_1.setBounds(369, 101, 59, 23);
		f.getContentPane().add(btnNewButton_1);

		JLabel label = new JLabel("Side:");
		label.setFont(new Font("Calibri", Font.BOLD, 13));
		label.setBounds(123, 104, 59, 17);
		f.getContentPane().add(label);

		comboBoxValueMod = new JComboBox();
		comboBoxValueMod.setModel(new DefaultComboBoxModel(new String[] { "BLUFOR", "OPFOR", "IND" }));
		comboBoxValueMod.setBounds(152, 101, 89, 23);
		f.getContentPane().add(comboBoxValueMod);

		JButton btnMorale = new JButton("Mor.");
		btnMorale.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.moral + (int) spinnerValueMod.getValue() > 100) {
							unit.moral = 100;
						} else {
							unit.moral += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnMorale.setBounds(309, 101, 59, 23);
		f.getContentPane().add(btnMorale);

		JButton btnSup = new JButton("Sup.");
		btnSup.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.suppression + (int) spinnerValueMod.getValue() > 100) {
							unit.suppression = 100;
						} else {
							unit.suppression += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnSup.setBounds(248, 101, 59, 23);
		f.getContentPane().add(btnSup);

		spinnerValueMod = new JSpinner();
		spinnerValueMod.setBounds(69, 102, 44, 20);
		f.getContentPane().add(spinnerValueMod);

		JButton btnNewButton_2 = new JButton("Hexes");
		btnNewButton_2.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				new HexWindow(gameWindow);

			}
		});
		btnNewButton_2.setBounds(10, 162, 128, 23);
		f.getContentPane().add(btnNewButton_2);

		JButton btnSet = new JButton("Set");
		btnSet.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
			}
		});
		btnSet.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				activeUnit = (int) spinnerActiveUnit.getValue();
				setUnitlabel();
			}
		});
		btnSet.setBounds(153, 132, 89, 23);
		f.getContentPane().add(btnSet);

		spinnerActiveUnit = new JSpinner();
		spinnerActiveUnit.setBounds(94, 133, 44, 20);
		f.getContentPane().add(spinnerActiveUnit);

		JLabel lblActiveUnit_1 = new JLabel("Active Unit:");
		lblActiveUnit_1.setFont(new Font("Calibri", Font.BOLD, 13));
		lblActiveUnit_1.setBounds(10, 134, 80, 17);
		f.getContentPane().add(lblActiveUnit_1);

		JButton btnClearAllSpotted = new JButton("Clear All Spotted");
		btnClearAllSpotted.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				
				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {

						// System.out.println("Clear Spot1");

						for (Unit unit : initiativeOrder) {

							for (Trooper trooper : unit.individuals) {

								trooper.spotted.clear();

							}

						}

						conflictLog.addNewLine("Cleared spotted.");
						
						// System.out.println("Clear Spot2");
						return null;
					}

				};

				worker.execute();
				
			}
		});
		btnClearAllSpotted.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				

			}
		});
		btnClearAllSpotted.setBounds(444, 132, 128, 23);
		f.getContentPane().add(btnClearAllSpotted);

		JButton btnRefreshCompanyUnits = new JButton("Refresh Company Units");
		btnRefreshCompanyUnits.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				refreshCompanyUnits();

			}

		});
		btnRefreshCompanyUnits.setBounds(231, 39, 165, 25);
		f.getContentPane().add(btnRefreshCompanyUnits);

		JButton btnSkipTo = new JButton("Skip To");
		btnSkipTo.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {
						int originalAU = activeUnit;
						int newActiveUnit = (int) spinnerActiveUnit.getValue();
						
						//System.out.println("Original AU: "+originalAU);
						//System.out.println("Next Active Unit: "+newActiveUnit);
						
						if (newActiveUnit <= originalAU) {

							// Skips to end of init order
							for (int i = originalAU; i < initiativeOrder.size(); i++) {

								try {

									if(newActiveUnit == 0 
											&& newActiveUnit != originalAU 
											&& i == initiativeOrder.size() - 1)
										return null;
									
									safeNextActiveUnit();

								} catch (Exception e2) {
									e2.printStackTrace();
								}

							}
							
							
							
							// skips to active unit
							for (int i = 0; i < newActiveUnit; i++) {

								try {

									safeNextActiveUnit();

								} catch (Exception e2) {
									e2.printStackTrace();
								}

							}

						} else {
							for (int i = originalAU; i < newActiveUnit; i++) {

								/*
								 * for(Trooper trooper : initiativeOrder.get(i).individuals) {
								 * if(game.getPhase() == 1) { trooper.spentPhase1 = game.getCurrentAction(); }
								 * else { trooper.spentPhase2 = game.getCurrentAction(); } }
								 */

								try {

									safeNextActiveUnit();

								} catch (Exception e2) {
									System.out.println("toString(): " + e2.toString());
									System.out.println("getMessage(): " + e2.getMessage());
									System.out.println("StackTrace: ");
									e2.printStackTrace();
								}

							}
						}
						
						return null;
					}

					@Override
					protected void done() {
						conflictLog.addQueuedText();
						guiUpdateNextActiveUnit();

						if(hexGrid != null) {
							hexGrid.panel.shownType = HexGridUtility.getShownTypeFromSide(initiativeOrder.get(activeUnit).side);
						}
						
						openUnit(initiativeOrder.get(activeUnit), activeUnit);
						hexGrid.frame.toFront();
						hexGrid.frame.requestFocus();
					}

				};

				worker.execute();

			}
		});
		btnSkipTo.setBounds(248, 133, 113, 23);
		f.getContentPane().add(btnSkipTo);

		JLabel lblHexSize = new JLabel("Hex Size:");
		lblHexSize.setFont(new Font("Calibri", Font.BOLD, 13));
		lblHexSize.setBounds(406, 41, 59, 17);
		f.getContentPane().add(lblHexSize);

		spinnerHexSize = new JSpinner();
		spinnerHexSize.setBounds(475, 39, 44, 20);
		f.getContentPane().add(spinnerHexSize);

		JButton btnSetHex = new JButton("Set Hex");
		btnSetHex.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {

				hexSize = (int) spinnerHexSize.getValue();
				conflictLog.addNewLine("Hex Size Set To " + hexSize);
			}
		});
		btnSetHex.setBounds(406, 70, 89, 23);
		f.getContentPane().add(btnSetHex);

		// System.out.println("Init order size: "+initiativeOrder.size());
		// Opens active unit
		if (initiativeOrder != null && initiativeOrder.size() > 0) {

			// Updates Lavels
			setUnitlabel();
			setRound();
			setPhase();
			setActions();

			if (openUnit) {
				Unit unit = initiativeOrder.get(activeUnit);
				openUnit(unit, activeUnit);
			}

			// System.out.println("Load Active Unit: "+activeUnit);
		}

		if (game.getDaylightCondition().equals(""))
			comboBoxVisibility.setSelectedIndex(0);

		// Creates hex grid
		// System.out.println("Create hex grid");
		this.hexGrid = new HexGrid(initiativeOrder, gameWindow, hexRows, hexCols);
		if (hexGrid != null && hexGrid.panel.deployedUnits.size() > 0) {
			hexGrid.panel.selectedUnit = hexGrid.panel.deployedUnits.get(activeUnit);
		}

		spinnerHexSize.setValue(hexSize);

		JButton btnNewButton_3 = new JButton("CQB Check");
		btnNewButton_3.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				if (currentlyOpenUnit == null) {
					conflictLog.addNewLine(
							"Use this button at the start of a conflict, specifically when some units are begining the conflict in close quarters battle. "
									+ "Open the first unit in the init order to perform a CQB check.");
					return;
				}

				closeQuartersBattleCheck(currentlyOpenUnit);
			}
		});
		btnNewButton_3.setBounds(444, 101, 128, 23);
		f.getContentPane().add(btnNewButton_3);

	}

	// Opens active unit window
	public void openUnit(Unit unit, int index) {
		// System.out.println("Open unit moral: "+unit.moral);

		try {
			if (currentlyOpenUnit != null)
				currentlyOpenUnit.f.dispose();
			currentlyOpenUnit = new OpenUnit(unit, gameWindow, index);
		} catch (Exception e) {
			System.out.println("toString(): " + e.toString());
			System.out.println("getMessage(): " + e.getMessage());
			System.out.println("StackTrace: ");
			e.printStackTrace();
		}

	}

	// Sets companies equal to the comapny in the setup window
	// Used to save changes made to a company during a conflict
	public void confirmCompany(Company company, int index) {
		setupWindow.setCompany(company, index);
		setupWindow.refreshCreated();
	}

	// Refresh conflict
	public void refreshConflict(SetupWindow setupWindow) {
		this.companies = setupWindow.getActivated();
		rollInitiativeOrder();
		refreshInitiativeOrder();
	}

	public void refreshInitiativeOrder() {
		DefaultListModel initiativeOrderList = new DefaultListModel();

		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Loops through troopers in the unit

			for (int x = 0; x < initiativeOrder.get(i).getSize(); x++) {
				Trooper currentTrooper = initiativeOrder.get(i).getTroopers().get(x);
				currentTrooper.number = x + 1;
			}

			initiativeOrderList.addElement(i + ": " + initiativeOrder.get(i));

		}

		listIniativeOrder.setModel(initiativeOrderList);

		setUnitlabel();
		
		if(hexGrid != null) {
			hexGrid.refreshDeployedUnits();
		}
		
	}

	// Loops through companies
	// Adds units to units array
	// Sets units sides, command value, and initiative
	public void setInitiativeOrder(ArrayList<Company> companies) {
		Random rand = new Random();

		initiativeOrder.clear();

		for (int i = 0; i < companies.size(); i++) {
			Company company = companies.get(i);
			ArrayList<Unit> units = company.getUnits();
			for (int j = 0; j < company.getUnitsLength(); j++) {
				Unit unit = units.get(j);
				// Sets some unit stats
				unit.side = company.getSide();
				unit.company = company.getName();
				unit.getCommandValue();
				int roll = rand.nextInt(10) + 1;
				unit.initiative = roll + unit.commandValue;
				if (unit.active) {
					initiativeOrder.add(unit);
				}

			}
		}

		rollInitiativeOrder();

	}

	// Sets initiative order
	public void rollInitiativeOrder() {

		Unit temp;

		for (int i = 0; i < initiativeOrder.size(); i++) {

			for (int j = 0; j < initiativeOrder.size() - 1; j++) {

				if (initiativeOrder.get(j + 1).initiative > initiativeOrder.get(j).initiative) {
					temp = initiativeOrder.get(j + 1);
					initiativeOrder.set(j + 1, initiativeOrder.get(j));
					initiativeOrder.set(j, temp);

				}
			}
		}

		closeCombatCheck();
		// closeQuartersBattleCheck();
	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void nextActiveUnit() {

		conflictLog.addNewLine("Next unit... Active Unit: " + activeUnit);

		int actions = game.getCurrentAction() + 1;

		// Increases passed active unit members by 1
		if (activeUnit > -1) {
			Unit unit = initiativeOrder.get(activeUnit);
			ArrayList<Trooper> troopers = unit.getTroopers();
			for (int j = 0; j < troopers.size(); j++) {

				// Increases time unconscious
				// Checks for wake up
				if (game.getCurrentAction() <= 3 && game.getCurrentAction() != 0) {

					if (!troopers.get(j).conscious) {

						if (troopers.get(j).timeUnconscious == troopers.get(j).incapacitationTime) {
							troopers.get(j).timeUnconscious = 0;
							troopers.get(j).incapacitationTime = 0;
							conflictLog.addNewLine(troopers.get(j).number + " " + troopers.get(j).name + " from unit:"
									+ unit.callsign + "has awoken.");
							troopers.get(j).conscious = true;
						} else {
							troopers.get(j).timeUnconscious++;
						}

					}

				}

				if (game.getPhase() == 1) {
					if (troopers.get(j).spentPhase1 != actions - 1) {

						if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1)
							troopers.get(j).spentPhase1 += 1;
					}
				} else {
					if (troopers.get(j).spentPhase2 != actions - 1) {

						if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2)
							troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			return;
		}

		int size = initiativeOrder.size();
		size--;

		// If next unit is empty
		// Skips next unit
		// System.out.println("Active Unit: "+activeUnit);
		int unitCount = 1;
		boolean pass = false;
		while (!pass) {

			// Makes sure there is a unit infront of the active unit
			if (activeUnit + unitCount != initiativeOrder.size()) {

				// Checks if the next unit is the last one
				if (activeUnit + 2 == initiativeOrder.size()) {
					// Checks if the last unit is empty
					if (initiativeOrder.get(activeUnit + 1).getSize() < 1) {
						activeUnit = size;
						break;
					}
				}

				// Checks if next unit is empty
				// If unit is alive and not empty
				if (initiativeOrder.get(activeUnit + unitCount).getSize() < 1) {
					// System.out.println("Increase");
					unitCount++;
				} else {

					pass = true;
					activeUnit += unitCount;
					activeUnit--;

				}

				/*
				 * if(activeUnit + unitCount > size || activeUnit > size) { activeUnit = size;
				 * break; }
				 */

				// System.out.println("Modified Active Unit: "+activeUnit);

			} else {
				break;
			}

		}

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		endOfInitOrder(size, actions);

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		openUnit(initiativeOrder.get(activeUnit), activeUnit);

		// Updates Labels
		setUnitlabel();
		setRound();
		setPhase();
		setActions();

	}

	// Performs nessesary checks for twenty seconds of passed time
	public void unitWaitTwentySeconds() {

		int actions = game.getCurrentAction();

		Unit unit = initiativeOrder.get(activeUnit);
		int activeTrooperCount = 0;
		int activeTroopersInCover = 0;
		// Forced Route or Pinned
		for (Trooper trooper : unit.getTroopers()) {

			if (trooper.alive && trooper.conscious) {
				activeTrooperCount++;
				if (trooper.inCover)
					activeTroopersInCover++;
			}

		}

		if (unit.suppression >= 50) {

			if ((double) activeTrooperCount / activeTroopersInCover < 0.5) {
				conflictLog.addNewLine(
						unit.callsign + " is forced to route due to high suppression and minimal cover. This "
								+ "unit can avoid routing if all individuals not in cover can hunker down.");
			} else {
				conflictLog.addNewLine(unit.callsign + " is pinned and cannot move until suppression "
						+ "becomes less than 50. Or a successful command test is made, with one difficulty die for every 10 suppression. "
						+ "And 1 bonus die for each additional leader.");
			}

		}

		// Fire Missions
		for (FireMission fireMission : unit.fireMissions) {
			// System.out.println("Calling Advance Time Fire Mission");
			fireMission.advanceTime();
		}

		ArrayList<Trooper> troopers = unit.getTroopers();
		for (int j = 0; j < troopers.size(); j++) {
			// System.out.println("Pass Trooper: "+j);

			if (!troopers.get(j).alive) {
				troopers.get(j).spentPhase1 = troopers.get(j).P1;
				troopers.get(j).spentPhase2 = troopers.get(j).P2;
				continue;
			}

			// Increases time unconscious
			// Checks for wake up
			if (actions <= 3 && actions != 0) {

				if (!troopers.get(j).conscious) {

					if (troopers.get(j).timeUnconscious >= troopers.get(j).incapacitationTime) {
						troopers.get(j).timeUnconscious = 0;
						troopers.get(j).incapacitationTime = 0;
						conflictLog.addNewLineToQueue(troopers.get(j).number + " " + troopers.get(j).name
								+ " from unit:" + unit.callsign + "has awoken.");
						troopers.get(j).conscious = true;

					} else {
						troopers.get(j).timeUnconscious++;
					}
					troopers.get(j).spentPhase1 = troopers.get(j).P1;
					troopers.get(j).spentPhase2 = troopers.get(j).P2;

					continue;

				}

				Trooper trooper = troopers.get(j);
				if (trooper.personalShield != null) {
					PersonalShield ps = trooper.personalShield;

					if (ps.currentShieldStrength < ps.maxShieldStrength) {

						ps.currentShieldStrength += ps.maxShieldStrength * ps.rechargeRate;

						if (ps.currentShieldStrength > ps.maxShieldStrength)
							ps.currentShieldStrength = ps.maxShieldStrength;

					}

				}

			}

			float time;

			if (gameWindow.game.getPhase() == 1) {
				if (troopers.get(j).P1 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P1;
			} else {
				if (troopers.get(j).P2 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P2;
			}

			if (unit.speed.equals("None")) {
				troopers.get(j).fatigueSystem.AddRecoveryTime(time);
			}

			if (game.getPhase() == 1) {
				if (troopers.get(j).spentPhase1 != actions) {

					if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1) {

						// troopers.get(j).spentPhase1 += 1;
					}
				}
			} else {
				if (troopers.get(j).spentPhase2 != actions) {

					if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2) {

						// troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}
	}

	// Performs nessesary checks for twenty seconds of passed time
	public void unitPassTwentySeconds() {

		int actions = game.getCurrentAction();

		Unit unit = initiativeOrder.get(activeUnit);
		int activeTrooperCount = 0;
		int activeTroopersInCover = 0;
		// Forced Route or Pinned
		for (Trooper trooper : unit.getTroopers()) {

			if (trooper.alive && trooper.conscious) {
				activeTrooperCount++;
				if (trooper.inCover)
					activeTroopersInCover++;
			}

		}

		if (unit.suppression >= 50) {

			if ((double) activeTrooperCount / activeTroopersInCover < 0.5) {
				conflictLog.addNewLine(
						unit.callsign + " is forced to route due to high suppression and minimal cover. This "
								+ "unit can avoid routing if all individuals not in cover can hunker down.");
			} else {
				conflictLog.addNewLine(unit.callsign + " is pinned and cannot move until suppression "
						+ "becomes less than 50. Or a successful command test is made, with one difficulty die for every 10 suppression. "
						+ "And 1 bonus die for each additional leader.");
			}

		}

		// Fire Missions
		for (FireMission fireMission : unit.fireMissions) {
			// System.out.println("Calling Advance Time Fire Mission");
			fireMission.advanceTime();
		}

		ArrayList<Trooper> troopers = unit.getTroopers();
		for (int j = 0; j < troopers.size(); j++) {
			// System.out.println("Pass Trooper: "+j);

			if (!troopers.get(j).alive) {
				troopers.get(j).spentPhase1 = troopers.get(j).P1;
				troopers.get(j).spentPhase2 = troopers.get(j).P2;
				continue;
			}

			// Increases time unconscious
			// Checks for wake up
			if (actions <= 3 && actions != 0) {

				if (!troopers.get(j).conscious) {

					if (troopers.get(j).timeUnconscious >= troopers.get(j).incapacitationTime) {
						troopers.get(j).timeUnconscious = 0;
						troopers.get(j).incapacitationTime = 0;
						conflictLog.addNewLineToQueue(troopers.get(j).number + " " + troopers.get(j).name
								+ " from unit:" + unit.callsign + "has awoken.");
						troopers.get(j).conscious = true;

					} else {
						troopers.get(j).timeUnconscious++;
					}
					troopers.get(j).spentPhase1 = troopers.get(j).P1;
					troopers.get(j).spentPhase2 = troopers.get(j).P2;

					continue;

				}

				Trooper trooper = troopers.get(j);
				if (trooper.personalShield != null) {
					PersonalShield ps = trooper.personalShield;

					if (ps.currentShieldStrength < ps.maxShieldStrength) {

						ps.currentShieldStrength += ps.maxShieldStrength * ps.rechargeRate;

						if (ps.currentShieldStrength > ps.maxShieldStrength)
							ps.currentShieldStrength = ps.maxShieldStrength;

					}

				}

			}

			float time;

			if (gameWindow.game.getPhase() == 1) {
				if (troopers.get(j).P1 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P1;
			} else {
				if (troopers.get(j).P2 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P2;
			}

			// System.out.println("Pass Add Recovery TIme");
			if (unit.speed.equals("None")) {
				troopers.get(j).fatigueSystem.AddRecoveryTime(time);
			}

			if (game.getPhase() == 1) {
				if (troopers.get(j).spentPhase1 != actions) {

					if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1) {

						troopers.get(j).spentPhase1 += 1;
					}
				}
			} else {
				if (troopers.get(j).spentPhase2 != actions) {

					if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2) {

						troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}
	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void safeNextActiveUnit() {
		// System.out.println("\n\nCurrent Action: "+game.getCurrentAction()+" Active
		// Unit: "+activeUnit+"\n\n");

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			// System.out.println("Returning Safe Next Active Unit");
			return;
		}

		unitPassTwentySeconds();

		int size = initiativeOrder.size();
		size--;

		/*
		 * activeUnit++; if(activeUnit == initiativeOrder.size()) activeUnit = 0;
		 */

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		// Might contain gui updates
		// System.out.println("Inside Pass1");
		endOfInitOrder(size, game.getCurrentAction() + 1);

		// System.out.println("Inside Pass2");

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		// listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		// System.out.println("Open Next Active Unit");

	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void safeWaitActiveUnit() {
		// System.out.println("\n\nCurrent Action: "+game.getCurrentAction()+" Active
		// Unit: "+activeUnit+"\n\n");

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			// System.out.println("Returning Safe Next Active Unit");
			return;
		}

		unitWaitTwentySeconds();

		int size = initiativeOrder.size();
		size--;

		/*
		 * activeUnit++; if(activeUnit == initiativeOrder.size()) activeUnit = 0;
		 */

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		// Might contain gui updates
		// System.out.println("Inside Pass1");
		endOfInitOrder(size, game.getCurrentAction() + 1);
		// System.out.println("Inside Pass2");

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		// listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		// System.out.println("Open Next Active Unit");

	}

	public void guiUpdateNextActiveUnit() {

		conflictLog.addNewLine("Next unit... Active Unit: " + activeUnit);

		// Updates Labels
		setUnitlabel();
		setRound();
		setPhase();
		setActions();

	}

	// Takes a trooper, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public static boolean exhaustedTrooper(Trooper trooper) {
		//System.out.println("Exuasted Trooper test: "+trooper.name);
		if (GameWindow.gameWindow.game.getPhase() == 1) {
			if (trooper.spentPhase1 < trooper.P1) {
				//System.out.println("Return False");
				return false;
			}
		} else {
			if (trooper.spentPhase2 < trooper.P2) {
				//System.out.println("Return False");
				return false;
			}
		}
		
		//System.out.println("Return True");
		return true;
	}

	// Takes a unit, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public static boolean exhaustedUnit(Unit unit) {

		// System.out.println("Entering Exhusted Unit Check");

		
		
		for (Trooper trooper : unit.getTroopers()) {
			if(!exhaustedTrooper(trooper))
				return false; 
		}

		// System.out.println("Returning True");
		return true;
	}
	
	public static boolean mostlyExhausted(Unit unit) {
		
		int exausted = 0, fresh = 0;
		
		for (Trooper trooper : unit.getTroopers()) {
			if(exhaustedTrooper(trooper))
				exausted++;
			else 
				fresh++; 
		}

		if(exausted >= fresh) {
			return true;
		} else {
			return false; 
		}
	}

	public static boolean anyoneExhausted(Unit unit) {
		for (Trooper trooper : unit.getTroopers()) {
			if(exhaustedTrooper(trooper))
				return true; 
		}

		// System.out.println("Returning True");
		return false;
	}
	
	// Returns true if all individuals have spent ap for this action, returns false
	// if they have not
	public boolean checkForAllExahusted() {

		for (Unit unit : initiativeOrder) {
			if (!exhaustedUnit(unit))
				return false;
		}

		return true;
	}

	// Takes a unit, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public boolean endActionUnit(Unit unit) {

		// System.out.println("Entering End Action Unit Check");

		for (Trooper trooper : unit.getTroopers()) {
			if (game.getPhase() == 1) {
				if (trooper.spentPhase1 < trooper.P1
						&& trooper.spentPhase1 < GameWindow.gameWindow.game.getCurrentAction()) {
					// System.out.println("Returning False");
					return false;
				}
			} else {
				if (trooper.spentPhase2 < trooper.P2
						&& trooper.spentPhase2 < GameWindow.gameWindow.game.getCurrentAction()) {
					// System.out.println("Returning False");
					return false;
				}
			}
		}

		// System.out.println("Returning True");
		return true;
	}

	// Returns true if all individuals have spent ap for this action, returns false
	// if they have not
	public boolean checkForAllEndAction() {

		for (Unit unit : initiativeOrder) {
			if (!endActionUnit(unit))
				return false;
		}

		return true;
	}

	// Checks and performs tasks for the end of the init order
	public void endOfInitOrder(int size, int actions) {

		boolean endOfPhase = checkForAllExahusted();
		boolean endOfAction = checkForAllEndAction();

		if (endOfPhase) {
			conflictLog.addNewLineToQueue("End of Phase");
			// game.setCurrentAction(actions);
			// conflictLog.addNewLineToQueue("Actions: " + actions);
			// Checks for end of phase
			// Loops through units indiviudals

			// Checks for artillery fire missions
			int diff = 3 - game.getCurrentAction();
			//System.out.println("diff: "+diff);
			for(Unit unit : initiativeOrder) {
				// Fire Missions
				for (FireMission fireMission : unit.fireMissions) {
					// System.out.println("Calling Advance Time Fire Mission");
					for(int i = 0; i < diff; i++) {
						fireMission.advanceTime();						
					}
					
				}
			}
			
			// Check for end of round or phase
			if (game.getPhase() == 1) {
				game.setPhase(2);
				// End of phase
				conflictLog.addNewLineToQueue("     Round: " + game.getRound() + " Phase: 2");
				endOfPhase();
			} else {
				game.setPhase(1);
				int round = game.getRound() + 1;
				game.setRound(round);
				conflictLog.addNewLineToQueue("     Round: " + game.getRound() + " Phase: 1");
				// End of round
				endOfPhase();
				endOfRound();

			}

			activeUnit = 0;
		} else if (endOfAction) {
			game.setCurrentAction(actions);
			conflictLog.addNewLineToQueue("End of Action");
			conflictLog.addNewLineToQueue("Actions: " + actions);
			activeUnit = 0;
			
			//System.out.println("End of action");
			
			// Action ended 
			for(DeployedUnit deployedUnit : hexGrid.panel.deployedUnits) {
				deployedUnit.moved = false; 
			}
			
			int currentAction = game.getCurrentAction();
			// Performs spot test
			if (currentAction == 1 || currentAction == 2 || currentAction == 3)
				spotCycle();

		} else if (activeUnit >= size) {

			for (int i = 0; i < initiativeOrder.size(); i++) {

				if (!endActionUnit(initiativeOrder.get(i))) {
					activeUnit = i;
					break;
				}

			}
			
			
			

		} else {
			activeUnit++;
		}
		

	}

	public void closeQuartersBattleCheck(OpenUnit openUnit) {

		cqb.closeQuartersBattleCheck(openUnit);

	}

	// Sets active unit label
	public void setUnitlabel() {
		if (initiativeOrder == null || initiativeOrder.size() < 1)
			return;
		else if (activeUnit > initiativeOrder.size())
			return;
		else if (activeUnit >= initiativeOrder.size()) {
			activeUnit = 0;
			return;
		} else if (initiativeOrder.get(activeUnit) == null)
			return;

		lblActiveUnit.setText("Active Unit: " + initiativeOrder.get(activeUnit).side + "::  "
				+ initiativeOrder.get(activeUnit).callsign);
	}

	// Set round
	public void setRound() {
		lblRound.setText("Round: " + game.getRound());
	}

	// Set phase
	public void setPhase() {
		lblPhase.setText("Phase: " + game.getPhase());

	}

	// Set actions
	public void setActions() {
		lblActions.setText("Actions: " + game.getCurrentAction());
	}

	// End of round
	// Loops through initiative order
	// Resets each troopers spentPhase AP to 0
	// Checks if a trooper is unconscious
	// If the trooper is unconscious increases the time unconscious by two minutes
	// Performs wake up tests is applicable
	public void endOfRound() {
		game.setCurrentAction(1);
		Random rand = new Random();

		// Loops through initiative order order
		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Gets current unit
			Unit unit = initiativeOrder.get(i);

			if (unit.behavior.equals("Recent Contact")) {
				unit.timeSinceContact += 1;

			}

			/*
			 * if(unit.timeSinceContact >= 5) { unit.behavior = "No Contact";
			 * unit.timeSinceContact = 0; }
			 */

			// Gets troopers
			ArrayList<Trooper> troopers = unit.getTroopers();

			// Loops through troopers
			for (int j = 0; j < unit.getSize(); j++) {
				Trooper trooper = troopers.get(j);
				// int TN = trooper.endurance;
				// Resets spent ap
				trooper.spentPhase1 = 0;
				trooper.spentPhase2 = 0;

				// Checks if trooper is conscious
				if (!trooper.conscious) {
					/*
					 * // Increases time spent unconscious trooper.timeUnconscious += 2;
					 * 
					 * // Performs wake up tests
					 * 
					 * 
					 * 
					 * if(trooper.timeUnconscious >= 14 && trooper.currentHP > 0) {
					 * trooper.conscious = true;
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has woken up..."); trooper.timeUnconscious = 0; }
					 * 
					 * 
					 * 
					 * int roll = rand.nextInt(100) + 1;
					 * 
					 * if(trooper.currentHP < -1 * trooper.hp) { if(trooper.timeUnconscious >= 718)
					 * { if(roll > TN) {
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has died of their injuries..."); trooper.alive = false; } } } else
					 * if(trooper.currentHP < 1) { if(trooper.timeUnconscious >= 58) { if(roll <=
					 * TN) {
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has woken up..."); trooper.conscious = true; trooper.timeUnconscious
					 * = 0; } } }
					 */

				}

				// Checks if trooper is mortally wounded
				/*
				 * if(trooper.mortallyWounded) { // Increases time spent mortally wounded
				 * trooper.timeMortallyWounded += 2;
				 * 
				 * // Checks if mortal wound is stabalized, makes rolls once per hour // If the
				 * character is not stablaized then rolls occur every half hour
				 * if(trooper.timeMortallyWounded >= 58 && trooper.stabalized) { int tempTN;
				 * 
				 * int skill = trooper.physicianSkill;
				 * 
				 * if(skill > TN) { tempTN = skill; } else { tempTN = TN; }
				 * 
				 * int roll = rand.nextInt(100) + 1; if(roll > tempTN) { trooper.alive = false;
				 * conflictLog.addNewLineToQueue(unit.callsign+":: "+trooper.name+", Number: "
				 * +trooper.number+" has died of their injuries..."); }
				 * 
				 * } else if(trooper.timeMortallyWounded >= 28) { int roll = rand.nextInt(100) +
				 * 1; if(roll > TN) { trooper.alive = false;
				 * conflictLog.addNewLineToQueue(unit.callsign+":: "+trooper.name+", Number: "
				 * +trooper.number+" has died of their injuries..."); } }
				 * 
				 * }
				 */

			}
		}
	}

	// End of phase

	public void endOfPhase() {

		// Loops through all individuals, increases time passed for wounds
		// Checks unit morale, forces individuals to hunker down that are subject to the
		// morale failure

		for (int i = 0; i < initiativeOrder.size(); i++) {

			for (int x = 0; x < initiativeOrder.get(i).getSize(); x++) {

				if (initiativeOrder.get(i).moral < 30) {
					Random rand = new Random();
					int roll = rand.nextInt(10) + 1;

					if (roll < initiativeOrder.get(i).getTroopers().get(x).P1
							+ initiativeOrder.get(i).getTroopers().get(x).P2) {

						if (initiativeOrder.get(i).getTroopers().get(x).inCover) {
							initiativeOrder.get(i).getTroopers().get(x).HD = true;
							conflictLog.addNewLineToQueue(initiativeOrder.get(i).getTroopers().get(x).number + " "
									+ initiativeOrder.get(i).getTroopers().get(x).name
									+ " hunkers down. Morale too low.");
						}

					}

				}

				initiativeOrder.get(i).getTroopers().get(x).advanceTime(this, conflictLog);
			}

		}

		for (int i = 0; i < initiativeOrder.size(); i++) {
			if (initiativeOrder.get(i).suppression - 10 > 0) {
				initiativeOrder.get(i).suppression -= 5;
			} else {
				initiativeOrder.get(i).suppression = 0;
			}

			if (initiativeOrder.get(i).behavior.equals("No Contact")) {
				initiativeOrder.get(i).organization += initiativeOrder.get(i).commandValue
						+ (initiativeOrder.get(i).moral / 20);
			} else if (initiativeOrder.get(i).behavior.equals("Recent Contact")) {
				initiativeOrder.get(i).organization += initiativeOrder.get(i).commandValue
						+ (initiativeOrder.get(i).moral / 20) / 2;
			}

			if (initiativeOrder.get(i).organization > 100) {

				initiativeOrder.get(i).organization = 100;

			}
		}

		// Loops through initiative order order
		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Gets current unit
			Unit unit = initiativeOrder.get(i);
			// Gets troopers
			ArrayList<Trooper> troopers = unit.getTroopers();

			// Loops through troopers
			for (int j = 0; j < unit.getSize(); j++) {
				Trooper trooper = troopers.get(j);

				// Checks for shields
				// Recharges sheilds
				if (trooper.shields > 0) {
					trooper.currentShields = trooper.shields;
				}

			}

		}

		game.setCurrentAction(1);

	}

	// Loops through each unit
	// Rolls spot for all individuals against units that are not on their side
	public void spotCycle() {

		for (Iterator<Unit> iteratorInitOrder = initiativeOrder.iterator(); iteratorInitOrder.hasNext();) {

			Unit spotterUnit = iteratorInitOrder.next();
			// System.out.println("Spotter Unit: "+spotterUnit);

			for (Iterator<Trooper> troopers = spotterUnit.individuals.iterator(); troopers.hasNext();) {
				Trooper spotterTrooper = troopers.next();
				// System.out.println("Spotter Trooper: "+spotterTrooper.name);
				for (Iterator<Unit> targetUnits = spotterUnit.lineOfSight.iterator(); targetUnits.hasNext();) {

					Unit targetUnit = targetUnits.next();
					// System.out.println("Target Unit: "+targetUnit.callsign);
					// System.out.println("Entering Spot 1");
					spot(targetUnit, spotterUnit, spotterTrooper);
					// System.out.println("Exiting Spot 2");
				}

			}

		}

		/*
		 * for (int i = 0; i < initiativeOrder.size(); i++) { // Gets spotter unit Unit
		 * spotterUnit = initiativeOrder.get(i);
		 * 
		 * // Loops through troopers for(int x = 0; x <
		 * spotterUnit.getTroopers().size(); x++) {
		 * 
		 * // Clears trooper's spot spotterUnit.getTroopers().get(x).spotted.clear();
		 * 
		 * // Loops through units a second time for (int j = 0; j <
		 * initiativeOrder.size(); j++) {
		 * 
		 * // If not the same unit if(!initiativeOrder.get(j).compareTo(spotterUnit) &&
		 * !initiativeOrder.get(j).side.equals(spotterUnit.side)) {
		 * 
		 * 
		 * // Performs spot test spot(initiativeOrder.get(j), spotterUnit,
		 * spotterUnit.getTroopers().get(x));
		 * 
		 * 
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 */

	}

	// Creates new spot action and adds it to trooper
	public void spot(Unit targetUnit, Unit spotterUnit, Trooper trooper) {
		// System.out.println("Target Unit: "+targetUnit.callsign);
		// System.out.println("spotterUnit: "+spotterUnit.callsign);

		for (Unit unit : spotterUnit.lineOfSight) {
			// System.out.println("Unit in LOS: "+unit.callsign);
		}

		// System.out.println("spotterUnitLOS: "+spotterUnit.lineOfSight);
		if (!spotterUnit.lineOfSight.contains(targetUnit)) {
			// System.out.println("No LOS to Units: Spotter Unit: "+spotterUnit.callsign+",
			// targetUnit: "+targetUnit.callsign);
			return;
		}

		// System.out.println("New Spot Action 1");
		Spot spotAction = new Spot(gameWindow, spotterUnit, targetUnit, trooper, "180 Degrees", gameWindow.visibility,
				gameWindow.initiativeOrder, gameWindow);
		// System.out.println("New Spot Action 2");
		// Set results in trooper
		trooper.spotted.add(spotAction);
		// System.out.println("New Spot Action 3");
	}

	// Takes units from companies not already in the init order
	// Makes an init roll
	public void refreshUnits() {

		Random rand = new Random();

		ArrayList<Company> companies = setupWindow.getActivated();

		for (int i = 0; i < companies.size(); i++) {
			Company company = companies.get(i);
			ArrayList<Unit> units = company.getUnits();
			for (int j = 0; j < company.getUnitsLength(); j++) {
				Unit unit = units.get(j);

				boolean alreadyExists = false;
				for (Unit initUnit : initiativeOrder) {
					if (unit.callsign.equals(initUnit.callsign))
						alreadyExists = true;
				}

				if (!alreadyExists) {
					// Sets some unit stats
					unit.side = company.getSide();
					unit.company = company.getName();
					unit.getCommandValue();

					if (game.getPhase() == 1) {
						for (Trooper trooper : unit.getTroopers()) {

							trooper.spentPhase1 = game.getCurrentAction() - 1;

							if (game.getCurrentAction() == 1)
								trooper.spentPhase1 = 0;

						}
					} else {
						for (Trooper trooper : unit.getTroopers()) {

							trooper.spentPhase1 = trooper.P1;
							trooper.spentPhase2 = game.getCurrentAction() - 1;

							if (game.getCurrentAction() == 1)
								trooper.spentPhase2 = 0;

						}
					}

					int roll = rand.nextInt(10) + 1;

					unit.initiative = roll + unit.commandValue;
					if (unit.active) {
						initiativeOrder.add(unit);
					}
				}

			}
		}

		// Removes deactivated units
		/*
		 * for(Unit unit : initiativeOrder) {
		 * 
		 * if(!unit.active) {
		 * 
		 * initiativeOrder.remove(unit);
		 * 
		 * }
		 * 
		 * }
		 */

		// rollInitiativeOrder();
		refreshInitiativeOrder();

	}

	// Loops through all units in the iniiative order, checks if close combat should
	// be initaited
	public void closeCombatCheck() {

		int size = initiativeOrder.size();

		for (int i = 0; i < size; i++) {

			Unit unit = initiativeOrder.get(i);
			boolean closeCombat = false;

			ArrayList<Trooper> flee = new ArrayList<>();
			boolean rout = false;

			for (int x = 0; x < size; x++) {

				Unit unit2 = initiativeOrder.get(x);

				if (!unit.compareTo(unit2)) {

					if (unit.X == unit2.X && unit.Y == unit2.Y && !unit.side.equals(unit2.side)) {
						closeCombat = true;
						Random rand = new Random();

						if (!unit.closeCombat) {
							unit.closeCombat = true;

							if (unit.individuals.size() > 0) {

								int leaderShipRoll = rand.nextInt(100) + 1;

								// System.out.println("LR Roll 1: "+leaderShipRoll);

								if (unit.moral < 60) {
									int margin = 60 - unit.moral;
									margin = margin / 10;
									leaderShipRoll += margin * 10;

								}

								// System.out.println("LR Roll Modded: "+leaderShipRoll);

								gameWindow.conflictLog.addNewLine("Entering Close Combat: " + unit.callsign);
								gameWindow.conflictLog.addNewLine("Command: " + unit.individuals.get(0).command);
								gameWindow.conflictLog.addNewLine("Leadership Roll: " + leaderShipRoll);
								gameWindow.conflictLog.addNewLine("Unit Morale: " + unit.moral);

								if (leaderShipRoll > unit.individuals.get(0).command) {
									for (int j = 0; j < unit.individuals.size(); j++) {
										int roll = rand.nextInt(100) + 1;
										gameWindow.conflictLog.addNewLine(unit.individuals.get(j).name + " "
												+ unit.individuals.get(j).number + " Morale Roll: " + roll);

										if (roll > unit.moral) {
											flee.add(unit.individuals.get(j));
											rout = true;

										}
									}
								}
							}

						}

					}

				}

			}
			if (!closeCombat) {
				unit.closeCombat = false;
			}

			if (rout) {
				unit.flee(gameWindow, unit, flee);
			}

		}

	}

	// Targets X and Y, returns hex
	public Hex findHex(int x, int y) {

		for (Hex hex : hexes) {
			if (hex.xCord == x && hex.yCord == y)
				return hex;
		}

		return null;

	}

	// Finds the differance between the two locations
	public static int hexDif(Unit targetUnit, Unit shooterUnit) {
		return hexDif(targetUnit.X, targetUnit.Y, shooterUnit.X, shooterUnit.Y);
	}

	// Finds the differance between the two locations
	public static int hexDif(int x, int y, Unit shooterUnit) {
		return hexDif(x, y, shooterUnit.X, shooterUnit.Y);
	}

	public static int hexDif(int x, int y, int x1, int y1) {
		return dist(x, y, x1, y1);
	}
	
	public static int dist(int x1, int x2, int y1, int y2) {
		
		int du = x2 - x1;
		int dv = Math.floorDiv()(y2 + x2 / 2)
		
		
	}
	
	
	public ArrayList<Unit> getUnitsInHex(String sideSpecified, int x, int y) {

		ArrayList<Unit> units = new ArrayList<>();

		for (Unit unit : initiativeOrder) {
			if (unit.X != x || unit.Y != y)
				continue;

			if (unit.side.equals(sideSpecified) || (sideSpecified.equals("") || sideSpecified.equals("None"))) {
				units.add(unit);
			}
		}

		return units;
	}

	public ArrayList<Unit> getUnitsInHexExcludingSide(String sideSpecified, int x, int y) {

		ArrayList<Unit> units = new ArrayList<>();

		for (Unit unit : initiativeOrder) {
			if (unit.X != x || unit.Y != y)
				continue;

			// System.out.println("Add unit");
			if (!unit.side.equals(sideSpecified) || (sideSpecified.equals("") || sideSpecified.equals("None"))) {
				units.add(unit);
			}
		}

		return units;
	}

	public static String getLogHead(Trooper target) {
		return GameWindow.findTrooperUnit(target).callsign + ", " + target.number + ": " + target.name;
	}

	public static void addTrooperEntryToLog(Trooper trooper, String text) {
		GameWindow.gameWindow.conflictLog.addNewLineToQueue(GameWindow.gameWindow.getLogHead(trooper) + " " + text);
	}

	// Loops through units in initiaitive order
	// Looks for unit containing indvididual
	// Returns unit
	public static Unit findTrooperUnit(Trooper trooper) {
		ArrayList<Unit> units = gameWindow.initiativeOrder;

		for (Unit unit : units) {

			for (Trooper trooper1 : unit.getTroopers()) {

				if (trooper1.compareTo(trooper))
					return unit;

			}

		}

		return null;

	}

	public void randomEventCheck() {
		Random rand = new Random();

		if (rand.nextInt(100) + 1 < 5) {
			conflictLog.addNewLine("Random Event Has Occured");
		}

	}

	public void refreshCompanyUnits() {
		// Auto-generated method stub
		conflictLog.addNewLine("Refreshed Units");

		for (Unit unit : initiativeOrder) {

			for (Company company : setupWindow.companies) {

				if (company.getName().equals(unit.company)) {

					for (Unit secondUnit : company.getUnits()) {

						if (secondUnit.callsign.equals(unit.callsign))
							company.getUnits().set(company.getUnits().indexOf(secondUnit), unit);

					}

				}

			}

		}

		setupWindow.refreshCreated();
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-01 11:46:29.686
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-01 11:46:29.687
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-01 11:46:29.860
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package Conflict;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.Random;

import javax.swing.DefaultListModel;
import javax.swing.JFrame;
import javax.swing.JScrollPane;

import Company.Company;
import CreateGame.SetupWindow;
import HexGrid.HexGrid;
import HexGrid.HexGrid.DeployedUnit;
import Hexes.Hex;
import Hexes.HexWindow;
import Items.PersonalShield;
import Trooper.Trooper;
import Unit.Unit;
import UtilityClasses.HexGridUtility;

import javax.swing.JList;
import javax.swing.JButton;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import java.lang.reflect.Array;

import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.JLabel;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.Toolkit;

import javax.swing.LayoutStyle.ComponentPlacement;

import Actions.Spot;
import Artillery.FireMission;

import javax.swing.JComboBox;
import javax.swing.DefaultComboBoxModel;
import java.awt.event.ItemListener;
import java.awt.event.ItemEvent;
import javax.swing.JSpinner;
import javax.swing.SwingWorker;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

public class GameWindow implements Serializable {
	public static int hexSize = 20;
	public ArrayList<Company> companies;
	public ArrayList<Unit> initiativeOrder = new ArrayList<Unit>();
	public Game game;
	public String visibility = "Good Visibility";
	public ArrayList<Hex> hexes = new ArrayList<Hex>();
	public CloseQuartersBattle cqb = new CloseQuartersBattle(this);
	public ConflictLog conflictLog;
	public static GameWindow gameWindow;

	public SetupWindow setupWindow;
	public JList listIniativeOrder;
	public JFrame f = null;
	public int activeUnit = 0;
	private JLabel lblActiveUnit;
	private JLabel lblRound;
	private JLabel lblPhase;
	private JLabel lblActions;
	public JComboBox comboBoxVisibility;
	private JButton btnStartingSpotTest;
	private JSpinner spinnerInitMod;
	private JComboBox comboBoxInitModSide;
	private JComboBox comboBoxValueMod;
	private JSpinner spinnerValueMod;
	private JSpinner spinnerActiveUnit;
	public HexGrid hexGrid;
	public boolean cqbWindowOpen = false;
	public OpenUnit currentlyOpenUnit;
	private JSpinner spinnerHexSize;
	public int hexCols; 
	public int hexRows; 
	

	/**
	 * Launch the application.
	 */
	public GameWindow(ArrayList<Company> companiesFromSetupWindow, SetupWindow setupWindow, Game game,
			boolean openUnit, int hexRows, int hexCols) {
		this.hexCols = hexCols;
		this.hexRows = hexRows; 
		this.game = game;
		this.gameWindow = this;
		this.conflictLog = new ConflictLog();
		this.setupWindow = setupWindow;
		this.companies = companiesFromSetupWindow;
		conflictLog.addNewLine("     Round: " + game.getRound() + " Phase: " + game.getPhase());
		f = new JFrame("Conflict");
		f.setSize(600, 545);

		// Get the screen size
		Toolkit toolkit = Toolkit.getDefaultToolkit();
		Dimension screenSize = toolkit.getScreenSize();
		// Calculate the frame location
		int x = (screenSize.width - f.getWidth()) / 2;
		int y = (screenSize.height - f.getHeight()) / 2;

		// Set the new frame location
		f.setLocation(x, y);

		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent ev) {
				// frame.dispose();
			}
		});

		JScrollPane scrollPane = new JScrollPane();
		scrollPane.setBounds(10, 196, 564, 302);

		listIniativeOrder = new JList();
		listIniativeOrder.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				Unit unit = initiativeOrder.get(listIniativeOrder.getSelectedIndex());
				// System.out.println("Open unit moral: "+unit.moral);

				if (currentlyOpenUnit != null)
					currentlyOpenUnit.f.dispose();
				currentlyOpenUnit = new OpenUnit(unit, gameWindow, listIniativeOrder.getSelectedIndex());
			}
		});
		scrollPane.setViewportView(listIniativeOrder);

		JButton btnRefreshUnits = new JButton("Add New Units");
		btnRefreshUnits.setBounds(10, 39, 128, 25);
		btnRefreshUnits.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				refreshUnits();

			}
		});

		lblActiveUnit = new JLabel("Active Unit: ");
		lblActiveUnit.setBounds(328, 11, 233, 17);
		lblActiveUnit.setFont(new Font("Calibri", Font.BOLD, 13));

		lblRound = new JLabel("Round:");
		lblRound.setBounds(10, 11, 113, 17);
		lblRound.setFont(new Font("Calibri", Font.BOLD, 13));

		lblPhase = new JLabel("Phase:");
		lblPhase.setBounds(129, 11, 113, 17);
		lblPhase.setFont(new Font("Calibri", Font.BOLD, 13));

		lblActions = new JLabel("Actions:");
		lblActions.setBounds(248, 11, 113, 17);
		lblActions.setFont(new Font("Calibri", Font.BOLD, 13));

		JButton btnD = new JButton("D100");
		btnD.setBounds(148, 40, 69, 23);
		btnD.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {
				Random rand = new Random();
				int roll = rand.nextInt(100) + 1;
				conflictLog.addNewLine("Roll: " + roll);
			}
		});

		comboBoxVisibility = new JComboBox();
		comboBoxVisibility.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {

				visibility = comboBoxVisibility.getSelectedItem().toString();
				game.setDaylightCondition(visibility);

			}
		});
		comboBoxVisibility.setBounds(219, 162, 193, 23);
		comboBoxVisibility.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent arg0) {

			}
		});
		comboBoxVisibility.setModel(new DefaultComboBoxModel(
				new String[] { "Good Visibility", "Dusk", "Night - Full Moon ", "Night - Half Moon", "Night - No Moon",
						"Smoke/Fog/Haze/Overcast", "Dusk - Smoke/Fog/Haze/Overcast", "Night - Smoke/Fog/Haze/Overcast",
						"No Visibility - Heavy Fog - White Out" }));

		JLabel lblVisibility = new JLabel("Visibility:");
		lblVisibility.setBounds(152, 165, 59, 17);
		lblVisibility.setFont(new Font("Calibri", Font.BOLD, 13));

		btnStartingSpotTest = new JButton("General Spot Test");
		btnStartingSpotTest.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
			}
		});
		btnStartingSpotTest.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {

						// System.out.println("Spot1");
						spotCycle();
						// System.out.println("Spot2");
						return null;
					}

					@Override
					protected void done() {

						// System.out.println("Done");
						gameWindow.conflictLog.addQueuedText();
						gameWindow.conflictLog.addNewLine("General Spot Test Completed");
					}

				};

				worker.execute();

			}
		});
		btnStartingSpotTest.setBounds(444, 162, 128, 23);
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

		setInitiativeOrder(companies);
		refreshInitiativeOrder();

		// Sets next active unit
		listIniativeOrder.setSelectedIndex(activeUnit);
		f.getContentPane().setLayout(null);
		f.getContentPane().add(btnStartingSpotTest);
		f.getContentPane().add(scrollPane);
		f.getContentPane().add(lblVisibility);
		f.getContentPane().add(comboBoxVisibility);
		f.getContentPane().add(btnRefreshUnits);
		f.getContentPane().add(lblRound);
		f.getContentPane().add(lblPhase);
		f.getContentPane().add(lblActions);
		f.getContentPane().add(lblActiveUnit);
		f.getContentPane().add(btnD);

		JButton btnNewButton = new JButton("Roll Init Order");
		btnNewButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				setInitiativeOrder(companies);

				for (Unit unit : initiativeOrder) {
					if (unit.side.equals(comboBoxInitModSide.getSelectedItem()))
						unit.initiative += (int) spinnerInitMod.getValue();
				}

				rollInitiativeOrder();
				refreshInitiativeOrder();
			}
		});
		btnNewButton.setBounds(256, 70, 128, 23);
		f.getContentPane().add(btnNewButton);

		JLabel lblInitMod = new JLabel("Init Mod:");
		lblInitMod.setFont(new Font("Calibri", Font.BOLD, 13));
		lblInitMod.setBounds(133, 73, 59, 17);
		f.getContentPane().add(lblInitMod);

		spinnerInitMod = new JSpinner();
		spinnerInitMod.setBounds(202, 71, 44, 20);
		f.getContentPane().add(spinnerInitMod);

		comboBoxInitModSide = new JComboBox();
		comboBoxInitModSide.setModel(new DefaultComboBoxModel(new String[] { "BLUFOR", "OPFOR", "IND" }));
		comboBoxInitModSide.setSelectedIndex(0);
		comboBoxInitModSide.setBounds(48, 68, 75, 23);
		f.getContentPane().add(comboBoxInitModSide);

		JLabel lblSide = new JLabel("Side:");
		lblSide.setFont(new Font("Calibri", Font.BOLD, 13));
		lblSide.setBounds(10, 72, 59, 17);
		f.getContentPane().add(lblSide);

		JLabel lblValueMod = new JLabel("Stat Mod:");
		lblValueMod.setFont(new Font("Calibri", Font.BOLD, 13));
		lblValueMod.setBounds(10, 104, 59, 17);
		f.getContentPane().add(lblValueMod);

		JButton btnNewButton_1 = new JButton("Org.");
		btnNewButton_1.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.organization + (int) spinnerValueMod.getValue() > 100) {
							unit.organization = 100;
						} else {
							unit.organization += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnNewButton_1.setBounds(369, 101, 59, 23);
		f.getContentPane().add(btnNewButton_1);

		JLabel label = new JLabel("Side:");
		label.setFont(new Font("Calibri", Font.BOLD, 13));
		label.setBounds(123, 104, 59, 17);
		f.getContentPane().add(label);

		comboBoxValueMod = new JComboBox();
		comboBoxValueMod.setModel(new DefaultComboBoxModel(new String[] { "BLUFOR", "OPFOR", "IND" }));
		comboBoxValueMod.setBounds(152, 101, 89, 23);
		f.getContentPane().add(comboBoxValueMod);

		JButton btnMorale = new JButton("Mor.");
		btnMorale.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.moral + (int) spinnerValueMod.getValue() > 100) {
							unit.moral = 100;
						} else {
							unit.moral += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnMorale.setBounds(309, 101, 59, 23);
		f.getContentPane().add(btnMorale);

		JButton btnSup = new JButton("Sup.");
		btnSup.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.suppression + (int) spinnerValueMod.getValue() > 100) {
							unit.suppression = 100;
						} else {
							unit.suppression += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnSup.setBounds(248, 101, 59, 23);
		f.getContentPane().add(btnSup);

		spinnerValueMod = new JSpinner();
		spinnerValueMod.setBounds(69, 102, 44, 20);
		f.getContentPane().add(spinnerValueMod);

		JButton btnNewButton_2 = new JButton("Hexes");
		btnNewButton_2.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				new HexWindow(gameWindow);

			}
		});
		btnNewButton_2.setBounds(10, 162, 128, 23);
		f.getContentPane().add(btnNewButton_2);

		JButton btnSet = new JButton("Set");
		btnSet.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
			}
		});
		btnSet.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				activeUnit = (int) spinnerActiveUnit.getValue();
				setUnitlabel();
			}
		});
		btnSet.setBounds(153, 132, 89, 23);
		f.getContentPane().add(btnSet);

		spinnerActiveUnit = new JSpinner();
		spinnerActiveUnit.setBounds(94, 133, 44, 20);
		f.getContentPane().add(spinnerActiveUnit);

		JLabel lblActiveUnit_1 = new JLabel("Active Unit:");
		lblActiveUnit_1.setFont(new Font("Calibri", Font.BOLD, 13));
		lblActiveUnit_1.setBounds(10, 134, 80, 17);
		f.getContentPane().add(lblActiveUnit_1);

		JButton btnClearAllSpotted = new JButton("Clear All Spotted");
		btnClearAllSpotted.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				
				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {

						// System.out.println("Clear Spot1");

						for (Unit unit : initiativeOrder) {

							for (Trooper trooper : unit.individuals) {

								trooper.spotted.clear();

							}

						}

						conflictLog.addNewLine("Cleared spotted.");
						
						// System.out.println("Clear Spot2");
						return null;
					}

				};

				worker.execute();
				
			}
		});
		btnClearAllSpotted.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				

			}
		});
		btnClearAllSpotted.setBounds(444, 132, 128, 23);
		f.getContentPane().add(btnClearAllSpotted);

		JButton btnRefreshCompanyUnits = new JButton("Refresh Company Units");
		btnRefreshCompanyUnits.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				refreshCompanyUnits();

			}

		});
		btnRefreshCompanyUnits.setBounds(231, 39, 165, 25);
		f.getContentPane().add(btnRefreshCompanyUnits);

		JButton btnSkipTo = new JButton("Skip To");
		btnSkipTo.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {
						int originalAU = activeUnit;
						int newActiveUnit = (int) spinnerActiveUnit.getValue();
						
						//System.out.println("Original AU: "+originalAU);
						//System.out.println("Next Active Unit: "+newActiveUnit);
						
						if (newActiveUnit <= originalAU) {

							// Skips to end of init order
							for (int i = originalAU; i < initiativeOrder.size(); i++) {

								try {

									if(newActiveUnit == 0 
											&& newActiveUnit != originalAU 
											&& i == initiativeOrder.size() - 1)
										return null;
									
									safeNextActiveUnit();

								} catch (Exception e2) {
									e2.printStackTrace();
								}

							}
							
							
							
							// skips to active unit
							for (int i = 0; i < newActiveUnit; i++) {

								try {

									safeNextActiveUnit();

								} catch (Exception e2) {
									e2.printStackTrace();
								}

							}

						} else {
							for (int i = originalAU; i < newActiveUnit; i++) {

								/*
								 * for(Trooper trooper : initiativeOrder.get(i).individuals) {
								 * if(game.getPhase() == 1) { trooper.spentPhase1 = game.getCurrentAction(); }
								 * else { trooper.spentPhase2 = game.getCurrentAction(); } }
								 */

								try {

									safeNextActiveUnit();

								} catch (Exception e2) {
									System.out.println("toString(): " + e2.toString());
									System.out.println("getMessage(): " + e2.getMessage());
									System.out.println("StackTrace: ");
									e2.printStackTrace();
								}

							}
						}
						
						return null;
					}

					@Override
					protected void done() {
						conflictLog.addQueuedText();
						guiUpdateNextActiveUnit();

						if(hexGrid != null) {
							hexGrid.panel.shownType = HexGridUtility.getShownTypeFromSide(initiativeOrder.get(activeUnit).side);
						}
						
						openUnit(initiativeOrder.get(activeUnit), activeUnit);
						hexGrid.frame.toFront();
						hexGrid.frame.requestFocus();
					}

				};

				worker.execute();

			}
		});
		btnSkipTo.setBounds(248, 133, 113, 23);
		f.getContentPane().add(btnSkipTo);

		JLabel lblHexSize = new JLabel("Hex Size:");
		lblHexSize.setFont(new Font("Calibri", Font.BOLD, 13));
		lblHexSize.setBounds(406, 41, 59, 17);
		f.getContentPane().add(lblHexSize);

		spinnerHexSize = new JSpinner();
		spinnerHexSize.setBounds(475, 39, 44, 20);
		f.getContentPane().add(spinnerHexSize);

		JButton btnSetHex = new JButton("Set Hex");
		btnSetHex.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {

				hexSize = (int) spinnerHexSize.getValue();
				conflictLog.addNewLine("Hex Size Set To " + hexSize);
			}
		});
		btnSetHex.setBounds(406, 70, 89, 23);
		f.getContentPane().add(btnSetHex);

		// System.out.println("Init order size: "+initiativeOrder.size());
		// Opens active unit
		if (initiativeOrder != null && initiativeOrder.size() > 0) {

			// Updates Lavels
			setUnitlabel();
			setRound();
			setPhase();
			setActions();

			if (openUnit) {
				Unit unit = initiativeOrder.get(activeUnit);
				openUnit(unit, activeUnit);
			}

			// System.out.println("Load Active Unit: "+activeUnit);
		}

		if (game.getDaylightCondition().equals(""))
			comboBoxVisibility.setSelectedIndex(0);

		// Creates hex grid
		// System.out.println("Create hex grid");
		this.hexGrid = new HexGrid(initiativeOrder, gameWindow, hexRows, hexCols);
		if (hexGrid != null && hexGrid.panel.deployedUnits.size() > 0) {
			hexGrid.panel.selectedUnit = hexGrid.panel.deployedUnits.get(activeUnit);
		}

		spinnerHexSize.setValue(hexSize);

		JButton btnNewButton_3 = new JButton("CQB Check");
		btnNewButton_3.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				if (currentlyOpenUnit == null) {
					conflictLog.addNewLine(
							"Use this button at the start of a conflict, specifically when some units are begining the conflict in close quarters battle. "
									+ "Open the first unit in the init order to perform a CQB check.");
					return;
				}

				closeQuartersBattleCheck(currentlyOpenUnit);
			}
		});
		btnNewButton_3.setBounds(444, 101, 128, 23);
		f.getContentPane().add(btnNewButton_3);

	}

	// Opens active unit window
	public void openUnit(Unit unit, int index) {
		// System.out.println("Open unit moral: "+unit.moral);

		try {
			if (currentlyOpenUnit != null)
				currentlyOpenUnit.f.dispose();
			currentlyOpenUnit = new OpenUnit(unit, gameWindow, index);
		} catch (Exception e) {
			System.out.println("toString(): " + e.toString());
			System.out.println("getMessage(): " + e.getMessage());
			System.out.println("StackTrace: ");
			e.printStackTrace();
		}

	}

	// Sets companies equal to the comapny in the setup window
	// Used to save changes made to a company during a conflict
	public void confirmCompany(Company company, int index) {
		setupWindow.setCompany(company, index);
		setupWindow.refreshCreated();
	}

	// Refresh conflict
	public void refreshConflict(SetupWindow setupWindow) {
		this.companies = setupWindow.getActivated();
		rollInitiativeOrder();
		refreshInitiativeOrder();
	}

	public void refreshInitiativeOrder() {
		DefaultListModel initiativeOrderList = new DefaultListModel();

		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Loops through troopers in the unit

			for (int x = 0; x < initiativeOrder.get(i).getSize(); x++) {
				Trooper currentTrooper = initiativeOrder.get(i).getTroopers().get(x);
				currentTrooper.number = x + 1;
			}

			initiativeOrderList.addElement(i + ": " + initiativeOrder.get(i));

		}

		listIniativeOrder.setModel(initiativeOrderList);

		setUnitlabel();
		
		if(hexGrid != null) {
			hexGrid.refreshDeployedUnits();
		}
		
	}

	// Loops through companies
	// Adds units to units array
	// Sets units sides, command value, and initiative
	public void setInitiativeOrder(ArrayList<Company> companies) {
		Random rand = new Random();

		initiativeOrder.clear();

		for (int i = 0; i < companies.size(); i++) {
			Company company = companies.get(i);
			ArrayList<Unit> units = company.getUnits();
			for (int j = 0; j < company.getUnitsLength(); j++) {
				Unit unit = units.get(j);
				// Sets some unit stats
				unit.side = company.getSide();
				unit.company = company.getName();
				unit.getCommandValue();
				int roll = rand.nextInt(10) + 1;
				unit.initiative = roll + unit.commandValue;
				if (unit.active) {
					initiativeOrder.add(unit);
				}

			}
		}

		rollInitiativeOrder();

	}

	// Sets initiative order
	public void rollInitiativeOrder() {

		Unit temp;

		for (int i = 0; i < initiativeOrder.size(); i++) {

			for (int j = 0; j < initiativeOrder.size() - 1; j++) {

				if (initiativeOrder.get(j + 1).initiative > initiativeOrder.get(j).initiative) {
					temp = initiativeOrder.get(j + 1);
					initiativeOrder.set(j + 1, initiativeOrder.get(j));
					initiativeOrder.set(j, temp);

				}
			}
		}

		closeCombatCheck();
		// closeQuartersBattleCheck();
	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void nextActiveUnit() {

		conflictLog.addNewLine("Next unit... Active Unit: " + activeUnit);

		int actions = game.getCurrentAction() + 1;

		// Increases passed active unit members by 1
		if (activeUnit > -1) {
			Unit unit = initiativeOrder.get(activeUnit);
			ArrayList<Trooper> troopers = unit.getTroopers();
			for (int j = 0; j < troopers.size(); j++) {

				// Increases time unconscious
				// Checks for wake up
				if (game.getCurrentAction() <= 3 && game.getCurrentAction() != 0) {

					if (!troopers.get(j).conscious) {

						if (troopers.get(j).timeUnconscious == troopers.get(j).incapacitationTime) {
							troopers.get(j).timeUnconscious = 0;
							troopers.get(j).incapacitationTime = 0;
							conflictLog.addNewLine(troopers.get(j).number + " " + troopers.get(j).name + " from unit:"
									+ unit.callsign + "has awoken.");
							troopers.get(j).conscious = true;
						} else {
							troopers.get(j).timeUnconscious++;
						}

					}

				}

				if (game.getPhase() == 1) {
					if (troopers.get(j).spentPhase1 != actions - 1) {

						if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1)
							troopers.get(j).spentPhase1 += 1;
					}
				} else {
					if (troopers.get(j).spentPhase2 != actions - 1) {

						if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2)
							troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			return;
		}

		int size = initiativeOrder.size();
		size--;

		// If next unit is empty
		// Skips next unit
		// System.out.println("Active Unit: "+activeUnit);
		int unitCount = 1;
		boolean pass = false;
		while (!pass) {

			// Makes sure there is a unit infront of the active unit
			if (activeUnit + unitCount != initiativeOrder.size()) {

				// Checks if the next unit is the last one
				if (activeUnit + 2 == initiativeOrder.size()) {
					// Checks if the last unit is empty
					if (initiativeOrder.get(activeUnit + 1).getSize() < 1) {
						activeUnit = size;
						break;
					}
				}

				// Checks if next unit is empty
				// If unit is alive and not empty
				if (initiativeOrder.get(activeUnit + unitCount).getSize() < 1) {
					// System.out.println("Increase");
					unitCount++;
				} else {

					pass = true;
					activeUnit += unitCount;
					activeUnit--;

				}

				/*
				 * if(activeUnit + unitCount > size || activeUnit > size) { activeUnit = size;
				 * break; }
				 */

				// System.out.println("Modified Active Unit: "+activeUnit);

			} else {
				break;
			}

		}

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		endOfInitOrder(size, actions);

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		openUnit(initiativeOrder.get(activeUnit), activeUnit);

		// Updates Labels
		setUnitlabel();
		setRound();
		setPhase();
		setActions();

	}

	// Performs nessesary checks for twenty seconds of passed time
	public void unitWaitTwentySeconds() {

		int actions = game.getCurrentAction();

		Unit unit = initiativeOrder.get(activeUnit);
		int activeTrooperCount = 0;
		int activeTroopersInCover = 0;
		// Forced Route or Pinned
		for (Trooper trooper : unit.getTroopers()) {

			if (trooper.alive && trooper.conscious) {
				activeTrooperCount++;
				if (trooper.inCover)
					activeTroopersInCover++;
			}

		}

		if (unit.suppression >= 50) {

			if ((double) activeTrooperCount / activeTroopersInCover < 0.5) {
				conflictLog.addNewLine(
						unit.callsign + " is forced to route due to high suppression and minimal cover. This "
								+ "unit can avoid routing if all individuals not in cover can hunker down.");
			} else {
				conflictLog.addNewLine(unit.callsign + " is pinned and cannot move until suppression "
						+ "becomes less than 50. Or a successful command test is made, with one difficulty die for every 10 suppression. "
						+ "And 1 bonus die for each additional leader.");
			}

		}

		// Fire Missions
		for (FireMission fireMission : unit.fireMissions) {
			// System.out.println("Calling Advance Time Fire Mission");
			fireMission.advanceTime();
		}

		ArrayList<Trooper> troopers = unit.getTroopers();
		for (int j = 0; j < troopers.size(); j++) {
			// System.out.println("Pass Trooper: "+j);

			if (!troopers.get(j).alive) {
				troopers.get(j).spentPhase1 = troopers.get(j).P1;
				troopers.get(j).spentPhase2 = troopers.get(j).P2;
				continue;
			}

			// Increases time unconscious
			// Checks for wake up
			if (actions <= 3 && actions != 0) {

				if (!troopers.get(j).conscious) {

					if (troopers.get(j).timeUnconscious >= troopers.get(j).incapacitationTime) {
						troopers.get(j).timeUnconscious = 0;
						troopers.get(j).incapacitationTime = 0;
						conflictLog.addNewLineToQueue(troopers.get(j).number + " " + troopers.get(j).name
								+ " from unit:" + unit.callsign + "has awoken.");
						troopers.get(j).conscious = true;

					} else {
						troopers.get(j).timeUnconscious++;
					}
					troopers.get(j).spentPhase1 = troopers.get(j).P1;
					troopers.get(j).spentPhase2 = troopers.get(j).P2;

					continue;

				}

				Trooper trooper = troopers.get(j);
				if (trooper.personalShield != null) {
					PersonalShield ps = trooper.personalShield;

					if (ps.currentShieldStrength < ps.maxShieldStrength) {

						ps.currentShieldStrength += ps.maxShieldStrength * ps.rechargeRate;

						if (ps.currentShieldStrength > ps.maxShieldStrength)
							ps.currentShieldStrength = ps.maxShieldStrength;

					}

				}

			}

			float time;

			if (gameWindow.game.getPhase() == 1) {
				if (troopers.get(j).P1 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P1;
			} else {
				if (troopers.get(j).P2 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P2;
			}

			if (unit.speed.equals("None")) {
				troopers.get(j).fatigueSystem.AddRecoveryTime(time);
			}

			if (game.getPhase() == 1) {
				if (troopers.get(j).spentPhase1 != actions) {

					if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1) {

						// troopers.get(j).spentPhase1 += 1;
					}
				}
			} else {
				if (troopers.get(j).spentPhase2 != actions) {

					if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2) {

						// troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}
	}

	// Performs nessesary checks for twenty seconds of passed time
	public void unitPassTwentySeconds() {

		int actions = game.getCurrentAction();

		Unit unit = initiativeOrder.get(activeUnit);
		int activeTrooperCount = 0;
		int activeTroopersInCover = 0;
		// Forced Route or Pinned
		for (Trooper trooper : unit.getTroopers()) {

			if (trooper.alive && trooper.conscious) {
				activeTrooperCount++;
				if (trooper.inCover)
					activeTroopersInCover++;
			}

		}

		if (unit.suppression >= 50) {

			if ((double) activeTrooperCount / activeTroopersInCover < 0.5) {
				conflictLog.addNewLine(
						unit.callsign + " is forced to route due to high suppression and minimal cover. This "
								+ "unit can avoid routing if all individuals not in cover can hunker down.");
			} else {
				conflictLog.addNewLine(unit.callsign + " is pinned and cannot move until suppression "
						+ "becomes less than 50. Or a successful command test is made, with one difficulty die for every 10 suppression. "
						+ "And 1 bonus die for each additional leader.");
			}

		}

		// Fire Missions
		for (FireMission fireMission : unit.fireMissions) {
			// System.out.println("Calling Advance Time Fire Mission");
			fireMission.advanceTime();
		}

		ArrayList<Trooper> troopers = unit.getTroopers();
		for (int j = 0; j < troopers.size(); j++) {
			// System.out.println("Pass Trooper: "+j);

			if (!troopers.get(j).alive) {
				troopers.get(j).spentPhase1 = troopers.get(j).P1;
				troopers.get(j).spentPhase2 = troopers.get(j).P2;
				continue;
			}

			// Increases time unconscious
			// Checks for wake up
			if (actions <= 3 && actions != 0) {

				if (!troopers.get(j).conscious) {

					if (troopers.get(j).timeUnconscious >= troopers.get(j).incapacitationTime) {
						troopers.get(j).timeUnconscious = 0;
						troopers.get(j).incapacitationTime = 0;
						conflictLog.addNewLineToQueue(troopers.get(j).number + " " + troopers.get(j).name
								+ " from unit:" + unit.callsign + "has awoken.");
						troopers.get(j).conscious = true;

					} else {
						troopers.get(j).timeUnconscious++;
					}
					troopers.get(j).spentPhase1 = troopers.get(j).P1;
					troopers.get(j).spentPhase2 = troopers.get(j).P2;

					continue;

				}

				Trooper trooper = troopers.get(j);
				if (trooper.personalShield != null) {
					PersonalShield ps = trooper.personalShield;

					if (ps.currentShieldStrength < ps.maxShieldStrength) {

						ps.currentShieldStrength += ps.maxShieldStrength * ps.rechargeRate;

						if (ps.currentShieldStrength > ps.maxShieldStrength)
							ps.currentShieldStrength = ps.maxShieldStrength;

					}

				}

			}

			float time;

			if (gameWindow.game.getPhase() == 1) {
				if (troopers.get(j).P1 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P1;
			} else {
				if (troopers.get(j).P2 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P2;
			}

			// System.out.println("Pass Add Recovery TIme");
			if (unit.speed.equals("None")) {
				troopers.get(j).fatigueSystem.AddRecoveryTime(time);
			}

			if (game.getPhase() == 1) {
				if (troopers.get(j).spentPhase1 != actions) {

					if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1) {

						troopers.get(j).spentPhase1 += 1;
					}
				}
			} else {
				if (troopers.get(j).spentPhase2 != actions) {

					if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2) {

						troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}
	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void safeNextActiveUnit() {
		// System.out.println("\n\nCurrent Action: "+game.getCurrentAction()+" Active
		// Unit: "+activeUnit+"\n\n");

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			// System.out.println("Returning Safe Next Active Unit");
			return;
		}

		unitPassTwentySeconds();

		int size = initiativeOrder.size();
		size--;

		/*
		 * activeUnit++; if(activeUnit == initiativeOrder.size()) activeUnit = 0;
		 */

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		// Might contain gui updates
		// System.out.println("Inside Pass1");
		endOfInitOrder(size, game.getCurrentAction() + 1);

		// System.out.println("Inside Pass2");

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		// listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		// System.out.println("Open Next Active Unit");

	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void safeWaitActiveUnit() {
		// System.out.println("\n\nCurrent Action: "+game.getCurrentAction()+" Active
		// Unit: "+activeUnit+"\n\n");

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			// System.out.println("Returning Safe Next Active Unit");
			return;
		}

		unitWaitTwentySeconds();

		int size = initiativeOrder.size();
		size--;

		/*
		 * activeUnit++; if(activeUnit == initiativeOrder.size()) activeUnit = 0;
		 */

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		// Might contain gui updates
		// System.out.println("Inside Pass1");
		endOfInitOrder(size, game.getCurrentAction() + 1);
		// System.out.println("Inside Pass2");

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		// listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		// System.out.println("Open Next Active Unit");

	}

	public void guiUpdateNextActiveUnit() {

		conflictLog.addNewLine("Next unit... Active Unit: " + activeUnit);

		// Updates Labels
		setUnitlabel();
		setRound();
		setPhase();
		setActions();

	}

	// Takes a trooper, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public static boolean exhaustedTrooper(Trooper trooper) {
		//System.out.println("Exuasted Trooper test: "+trooper.name);
		if (GameWindow.gameWindow.game.getPhase() == 1) {
			if (trooper.spentPhase1 < trooper.P1) {
				//System.out.println("Return False");
				return false;
			}
		} else {
			if (trooper.spentPhase2 < trooper.P2) {
				//System.out.println("Return False");
				return false;
			}
		}
		
		//System.out.println("Return True");
		return true;
	}

	// Takes a unit, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public static boolean exhaustedUnit(Unit unit) {

		// System.out.println("Entering Exhusted Unit Check");

		
		
		for (Trooper trooper : unit.getTroopers()) {
			if(!exhaustedTrooper(trooper))
				return false; 
		}

		// System.out.println("Returning True");
		return true;
	}
	
	public static boolean mostlyExhausted(Unit unit) {
		
		int exausted = 0, fresh = 0;
		
		for (Trooper trooper : unit.getTroopers()) {
			if(exhaustedTrooper(trooper))
				exausted++;
			else 
				fresh++; 
		}

		if(exausted >= fresh) {
			return true;
		} else {
			return false; 
		}
	}

	public static boolean anyoneExhausted(Unit unit) {
		for (Trooper trooper : unit.getTroopers()) {
			if(exhaustedTrooper(trooper))
				return true; 
		}

		// System.out.println("Returning True");
		return false;
	}
	
	// Returns true if all individuals have spent ap for this action, returns false
	// if they have not
	public boolean checkForAllExahusted() {

		for (Unit unit : initiativeOrder) {
			if (!exhaustedUnit(unit))
				return false;
		}

		return true;
	}

	// Takes a unit, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public boolean endActionUnit(Unit unit) {

		// System.out.println("Entering End Action Unit Check");

		for (Trooper trooper : unit.getTroopers()) {
			if (game.getPhase() == 1) {
				if (trooper.spentPhase1 < trooper.P1
						&& trooper.spentPhase1 < GameWindow.gameWindow.game.getCurrentAction()) {
					// System.out.println("Returning False");
					return false;
				}
			} else {
				if (trooper.spentPhase2 < trooper.P2
						&& trooper.spentPhase2 < GameWindow.gameWindow.game.getCurrentAction()) {
					// System.out.println("Returning False");
					return false;
				}
			}
		}

		// System.out.println("Returning True");
		return true;
	}

	// Returns true if all individuals have spent ap for this action, returns false
	// if they have not
	public boolean checkForAllEndAction() {

		for (Unit unit : initiativeOrder) {
			if (!endActionUnit(unit))
				return false;
		}

		return true;
	}

	// Checks and performs tasks for the end of the init order
	public void endOfInitOrder(int size, int actions) {

		boolean endOfPhase = checkForAllExahusted();
		boolean endOfAction = checkForAllEndAction();

		if (endOfPhase) {
			conflictLog.addNewLineToQueue("End of Phase");
			// game.setCurrentAction(actions);
			// conflictLog.addNewLineToQueue("Actions: " + actions);
			// Checks for end of phase
			// Loops through units indiviudals

			// Checks for artillery fire missions
			int diff = 3 - game.getCurrentAction();
			//System.out.println("diff: "+diff);
			for(Unit unit : initiativeOrder) {
				// Fire Missions
				for (FireMission fireMission : unit.fireMissions) {
					// System.out.println("Calling Advance Time Fire Mission");
					for(int i = 0; i < diff; i++) {
						fireMission.advanceTime();						
					}
					
				}
			}
			
			// Check for end of round or phase
			if (game.getPhase() == 1) {
				game.setPhase(2);
				// End of phase
				conflictLog.addNewLineToQueue("     Round: " + game.getRound() + " Phase: 2");
				endOfPhase();
			} else {
				game.setPhase(1);
				int round = game.getRound() + 1;
				game.setRound(round);
				conflictLog.addNewLineToQueue("     Round: " + game.getRound() + " Phase: 1");
				// End of round
				endOfPhase();
				endOfRound();

			}

			activeUnit = 0;
		} else if (endOfAction) {
			game.setCurrentAction(actions);
			conflictLog.addNewLineToQueue("End of Action");
			conflictLog.addNewLineToQueue("Actions: " + actions);
			activeUnit = 0;
			
			//System.out.println("End of action");
			
			// Action ended 
			for(DeployedUnit deployedUnit : hexGrid.panel.deployedUnits) {
				deployedUnit.moved = false; 
			}
			
			int currentAction = game.getCurrentAction();
			// Performs spot test
			if (currentAction == 1 || currentAction == 2 || currentAction == 3)
				spotCycle();

		} else if (activeUnit >= size) {

			for (int i = 0; i < initiativeOrder.size(); i++) {

				if (!endActionUnit(initiativeOrder.get(i))) {
					activeUnit = i;
					break;
				}

			}
			
			
			

		} else {
			activeUnit++;
		}
		

	}

	public void closeQuartersBattleCheck(OpenUnit openUnit) {

		cqb.closeQuartersBattleCheck(openUnit);

	}

	// Sets active unit label
	public void setUnitlabel() {
		if (initiativeOrder == null || initiativeOrder.size() < 1)
			return;
		else if (activeUnit > initiativeOrder.size())
			return;
		else if (activeUnit >= initiativeOrder.size()) {
			activeUnit = 0;
			return;
		} else if (initiativeOrder.get(activeUnit) == null)
			return;

		lblActiveUnit.setText("Active Unit: " + initiativeOrder.get(activeUnit).side + "::  "
				+ initiativeOrder.get(activeUnit).callsign);
	}

	// Set round
	public void setRound() {
		lblRound.setText("Round: " + game.getRound());
	}

	// Set phase
	public void setPhase() {
		lblPhase.setText("Phase: " + game.getPhase());

	}

	// Set actions
	public void setActions() {
		lblActions.setText("Actions: " + game.getCurrentAction());
	}

	// End of round
	// Loops through initiative order
	// Resets each troopers spentPhase AP to 0
	// Checks if a trooper is unconscious
	// If the trooper is unconscious increases the time unconscious by two minutes
	// Performs wake up tests is applicable
	public void endOfRound() {
		game.setCurrentAction(1);
		Random rand = new Random();

		// Loops through initiative order order
		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Gets current unit
			Unit unit = initiativeOrder.get(i);

			if (unit.behavior.equals("Recent Contact")) {
				unit.timeSinceContact += 1;

			}

			/*
			 * if(unit.timeSinceContact >= 5) { unit.behavior = "No Contact";
			 * unit.timeSinceContact = 0; }
			 */

			// Gets troopers
			ArrayList<Trooper> troopers = unit.getTroopers();

			// Loops through troopers
			for (int j = 0; j < unit.getSize(); j++) {
				Trooper trooper = troopers.get(j);
				// int TN = trooper.endurance;
				// Resets spent ap
				trooper.spentPhase1 = 0;
				trooper.spentPhase2 = 0;

				// Checks if trooper is conscious
				if (!trooper.conscious) {
					/*
					 * // Increases time spent unconscious trooper.timeUnconscious += 2;
					 * 
					 * // Performs wake up tests
					 * 
					 * 
					 * 
					 * if(trooper.timeUnconscious >= 14 && trooper.currentHP > 0) {
					 * trooper.conscious = true;
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has woken up..."); trooper.timeUnconscious = 0; }
					 * 
					 * 
					 * 
					 * int roll = rand.nextInt(100) + 1;
					 * 
					 * if(trooper.currentHP < -1 * trooper.hp) { if(trooper.timeUnconscious >= 718)
					 * { if(roll > TN) {
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has died of their injuries..."); trooper.alive = false; } } } else
					 * if(trooper.currentHP < 1) { if(trooper.timeUnconscious >= 58) { if(roll <=
					 * TN) {
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has woken up..."); trooper.conscious = true; trooper.timeUnconscious
					 * = 0; } } }
					 */

				}

				// Checks if trooper is mortally wounded
				/*
				 * if(trooper.mortallyWounded) { // Increases time spent mortally wounded
				 * trooper.timeMortallyWounded += 2;
				 * 
				 * // Checks if mortal wound is stabalized, makes rolls once per hour // If the
				 * character is not stablaized then rolls occur every half hour
				 * if(trooper.timeMortallyWounded >= 58 && trooper.stabalized) { int tempTN;
				 * 
				 * int skill = trooper.physicianSkill;
				 * 
				 * if(skill > TN) { tempTN = skill; } else { tempTN = TN; }
				 * 
				 * int roll = rand.nextInt(100) + 1; if(roll > tempTN) { trooper.alive = false;
				 * conflictLog.addNewLineToQueue(unit.callsign+":: "+trooper.name+", Number: "
				 * +trooper.number+" has died of their injuries..."); }
				 * 
				 * } else if(trooper.timeMortallyWounded >= 28) { int roll = rand.nextInt(100) +
				 * 1; if(roll > TN) { trooper.alive = false;
				 * conflictLog.addNewLineToQueue(unit.callsign+":: "+trooper.name+", Number: "
				 * +trooper.number+" has died of their injuries..."); } }
				 * 
				 * }
				 */

			}
		}
	}

	// End of phase

	public void endOfPhase() {

		// Loops through all individuals, increases time passed for wounds
		// Checks unit morale, forces individuals to hunker down that are subject to the
		// morale failure

		for (int i = 0; i < initiativeOrder.size(); i++) {

			for (int x = 0; x < initiativeOrder.get(i).getSize(); x++) {

				if (initiativeOrder.get(i).moral < 30) {
					Random rand = new Random();
					int roll = rand.nextInt(10) + 1;

					if (roll < initiativeOrder.get(i).getTroopers().get(x).P1
							+ initiativeOrder.get(i).getTroopers().get(x).P2) {

						if (initiativeOrder.get(i).getTroopers().get(x).inCover) {
							initiativeOrder.get(i).getTroopers().get(x).HD = true;
							conflictLog.addNewLineToQueue(initiativeOrder.get(i).getTroopers().get(x).number + " "
									+ initiativeOrder.get(i).getTroopers().get(x).name
									+ " hunkers down. Morale too low.");
						}

					}

				}

				initiativeOrder.get(i).getTroopers().get(x).advanceTime(this, conflictLog);
			}

		}

		for (int i = 0; i < initiativeOrder.size(); i++) {
			if (initiativeOrder.get(i).suppression - 10 > 0) {
				initiativeOrder.get(i).suppression -= 5;
			} else {
				initiativeOrder.get(i).suppression = 0;
			}

			if (initiativeOrder.get(i).behavior.equals("No Contact")) {
				initiativeOrder.get(i).organization += initiativeOrder.get(i).commandValue
						+ (initiativeOrder.get(i).moral / 20);
			} else if (initiativeOrder.get(i).behavior.equals("Recent Contact")) {
				initiativeOrder.get(i).organization += initiativeOrder.get(i).commandValue
						+ (initiativeOrder.get(i).moral / 20) / 2;
			}

			if (initiativeOrder.get(i).organization > 100) {

				initiativeOrder.get(i).organization = 100;

			}
		}

		// Loops through initiative order order
		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Gets current unit
			Unit unit = initiativeOrder.get(i);
			// Gets troopers
			ArrayList<Trooper> troopers = unit.getTroopers();

			// Loops through troopers
			for (int j = 0; j < unit.getSize(); j++) {
				Trooper trooper = troopers.get(j);

				// Checks for shields
				// Recharges sheilds
				if (trooper.shields > 0) {
					trooper.currentShields = trooper.shields;
				}

			}

		}

		game.setCurrentAction(1);

	}

	// Loops through each unit
	// Rolls spot for all individuals against units that are not on their side
	public void spotCycle() {

		for (Iterator<Unit> iteratorInitOrder = initiativeOrder.iterator(); iteratorInitOrder.hasNext();) {

			Unit spotterUnit = iteratorInitOrder.next();
			// System.out.println("Spotter Unit: "+spotterUnit);

			for (Iterator<Trooper> troopers = spotterUnit.individuals.iterator(); troopers.hasNext();) {
				Trooper spotterTrooper = troopers.next();
				// System.out.println("Spotter Trooper: "+spotterTrooper.name);
				for (Iterator<Unit> targetUnits = spotterUnit.lineOfSight.iterator(); targetUnits.hasNext();) {

					Unit targetUnit = targetUnits.next();
					// System.out.println("Target Unit: "+targetUnit.callsign);
					// System.out.println("Entering Spot 1");
					spot(targetUnit, spotterUnit, spotterTrooper);
					// System.out.println("Exiting Spot 2");
				}

			}

		}

		/*
		 * for (int i = 0; i < initiativeOrder.size(); i++) { // Gets spotter unit Unit
		 * spotterUnit = initiativeOrder.get(i);
		 * 
		 * // Loops through troopers for(int x = 0; x <
		 * spotterUnit.getTroopers().size(); x++) {
		 * 
		 * // Clears trooper's spot spotterUnit.getTroopers().get(x).spotted.clear();
		 * 
		 * // Loops through units a second time for (int j = 0; j <
		 * initiativeOrder.size(); j++) {
		 * 
		 * // If not the same unit if(!initiativeOrder.get(j).compareTo(spotterUnit) &&
		 * !initiativeOrder.get(j).side.equals(spotterUnit.side)) {
		 * 
		 * 
		 * // Performs spot test spot(initiativeOrder.get(j), spotterUnit,
		 * spotterUnit.getTroopers().get(x));
		 * 
		 * 
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 */

	}

	// Creates new spot action and adds it to trooper
	public void spot(Unit targetUnit, Unit spotterUnit, Trooper trooper) {
		// System.out.println("Target Unit: "+targetUnit.callsign);
		// System.out.println("spotterUnit: "+spotterUnit.callsign);

		for (Unit unit : spotterUnit.lineOfSight) {
			// System.out.println("Unit in LOS: "+unit.callsign);
		}

		// System.out.println("spotterUnitLOS: "+spotterUnit.lineOfSight);
		if (!spotterUnit.lineOfSight.contains(targetUnit)) {
			// System.out.println("No LOS to Units: Spotter Unit: "+spotterUnit.callsign+",
			// targetUnit: "+targetUnit.callsign);
			return;
		}

		// System.out.println("New Spot Action 1");
		Spot spotAction = new Spot(gameWindow, spotterUnit, targetUnit, trooper, "180 Degrees", gameWindow.visibility,
				gameWindow.initiativeOrder, gameWindow);
		// System.out.println("New Spot Action 2");
		// Set results in trooper
		trooper.spotted.add(spotAction);
		// System.out.println("New Spot Action 3");
	}

	// Takes units from companies not already in the init order
	// Makes an init roll
	public void refreshUnits() {

		Random rand = new Random();

		ArrayList<Company> companies = setupWindow.getActivated();

		for (int i = 0; i < companies.size(); i++) {
			Company company = companies.get(i);
			ArrayList<Unit> units = company.getUnits();
			for (int j = 0; j < company.getUnitsLength(); j++) {
				Unit unit = units.get(j);

				boolean alreadyExists = false;
				for (Unit initUnit : initiativeOrder) {
					if (unit.callsign.equals(initUnit.callsign))
						alreadyExists = true;
				}

				if (!alreadyExists) {
					// Sets some unit stats
					unit.side = company.getSide();
					unit.company = company.getName();
					unit.getCommandValue();

					if (game.getPhase() == 1) {
						for (Trooper trooper : unit.getTroopers()) {

							trooper.spentPhase1 = game.getCurrentAction() - 1;

							if (game.getCurrentAction() == 1)
								trooper.spentPhase1 = 0;

						}
					} else {
						for (Trooper trooper : unit.getTroopers()) {

							trooper.spentPhase1 = trooper.P1;
							trooper.spentPhase2 = game.getCurrentAction() - 1;

							if (game.getCurrentAction() == 1)
								trooper.spentPhase2 = 0;

						}
					}

					int roll = rand.nextInt(10) + 1;

					unit.initiative = roll + unit.commandValue;
					if (unit.active) {
						initiativeOrder.add(unit);
					}
				}

			}
		}

		// Removes deactivated units
		/*
		 * for(Unit unit : initiativeOrder) {
		 * 
		 * if(!unit.active) {
		 * 
		 * initiativeOrder.remove(unit);
		 * 
		 * }
		 * 
		 * }
		 */

		// rollInitiativeOrder();
		refreshInitiativeOrder();

	}

	// Loops through all units in the iniiative order, checks if close combat should
	// be initaited
	public void closeCombatCheck() {

		int size = initiativeOrder.size();

		for (int i = 0; i < size; i++) {

			Unit unit = initiativeOrder.get(i);
			boolean closeCombat = false;

			ArrayList<Trooper> flee = new ArrayList<>();
			boolean rout = false;

			for (int x = 0; x < size; x++) {

				Unit unit2 = initiativeOrder.get(x);

				if (!unit.compareTo(unit2)) {

					if (unit.X == unit2.X && unit.Y == unit2.Y && !unit.side.equals(unit2.side)) {
						closeCombat = true;
						Random rand = new Random();

						if (!unit.closeCombat) {
							unit.closeCombat = true;

							if (unit.individuals.size() > 0) {

								int leaderShipRoll = rand.nextInt(100) + 1;

								// System.out.println("LR Roll 1: "+leaderShipRoll);

								if (unit.moral < 60) {
									int margin = 60 - unit.moral;
									margin = margin / 10;
									leaderShipRoll += margin * 10;

								}

								// System.out.println("LR Roll Modded: "+leaderShipRoll);

								gameWindow.conflictLog.addNewLine("Entering Close Combat: " + unit.callsign);
								gameWindow.conflictLog.addNewLine("Command: " + unit.individuals.get(0).command);
								gameWindow.conflictLog.addNewLine("Leadership Roll: " + leaderShipRoll);
								gameWindow.conflictLog.addNewLine("Unit Morale: " + unit.moral);

								if (leaderShipRoll > unit.individuals.get(0).command) {
									for (int j = 0; j < unit.individuals.size(); j++) {
										int roll = rand.nextInt(100) + 1;
										gameWindow.conflictLog.addNewLine(unit.individuals.get(j).name + " "
												+ unit.individuals.get(j).number + " Morale Roll: " + roll);

										if (roll > unit.moral) {
											flee.add(unit.individuals.get(j));
											rout = true;

										}
									}
								}
							}

						}

					}

				}

			}
			if (!closeCombat) {
				unit.closeCombat = false;
			}

			if (rout) {
				unit.flee(gameWindow, unit, flee);
			}

		}

	}

	// Targets X and Y, returns hex
	public Hex findHex(int x, int y) {

		for (Hex hex : hexes) {
			if (hex.xCord == x && hex.yCord == y)
				return hex;
		}

		return null;

	}

	// Finds the differance between the two locations
	public static int hexDif(Unit targetUnit, Unit shooterUnit) {
		return hexDif(targetUnit.X, targetUnit.Y, shooterUnit.X, shooterUnit.Y);
	}

	// Finds the differance between the two locations
	public static int hexDif(int x, int y, Unit shooterUnit) {
		return hexDif(x, y, shooterUnit.X, shooterUnit.Y);
	}

	public static int hexDif(int x, int y, int x1, int y1) {
		return dist(x, y, x1, y1);
	}
	
	public static int dist(int x1, int x2, int y1, int y2) {
		
		int du = x2 - x1;
		int dv = Math.floorDiv()(y2 + x2 / 2)
		
		
	}
	
	
	public ArrayList<Unit> getUnitsInHex(String sideSpecified, int x, int y) {

		ArrayList<Unit> units = new ArrayList<>();

		for (Unit unit : initiativeOrder) {
			if (unit.X != x || unit.Y != y)
				continue;

			if (unit.side.equals(sideSpecified) || (sideSpecified.equals("") || sideSpecified.equals("None"))) {
				units.add(unit);
			}
		}

		return units;
	}

	public ArrayList<Unit> getUnitsInHexExcludingSide(String sideSpecified, int x, int y) {

		ArrayList<Unit> units = new ArrayList<>();

		for (Unit unit : initiativeOrder) {
			if (unit.X != x || unit.Y != y)
				continue;

			// System.out.println("Add unit");
			if (!unit.side.equals(sideSpecified) || (sideSpecified.equals("") || sideSpecified.equals("None"))) {
				units.add(unit);
			}
		}

		return units;
	}

	public static String getLogHead(Trooper target) {
		return GameWindow.findTrooperUnit(target).callsign + ", " + target.number + ": " + target.name;
	}

	public static void addTrooperEntryToLog(Trooper trooper, String text) {
		GameWindow.gameWindow.conflictLog.addNewLineToQueue(GameWindow.gameWindow.getLogHead(trooper) + " " + text);
	}

	// Loops through units in initiaitive order
	// Looks for unit containing indvididual
	// Returns unit
	public static Unit findTrooperUnit(Trooper trooper) {
		ArrayList<Unit> units = gameWindow.initiativeOrder;

		for (Unit unit : units) {

			for (Trooper trooper1 : unit.getTroopers()) {

				if (trooper1.compareTo(trooper))
					return unit;

			}

		}

		return null;

	}

	public void randomEventCheck() {
		Random rand = new Random();

		if (rand.nextInt(100) + 1 < 5) {
			conflictLog.addNewLine("Random Event Has Occured");
		}

	}

	public void refreshCompanyUnits() {
		// Auto-generated method stub
		conflictLog.addNewLine("Refreshed Units");

		for (Unit unit : initiativeOrder) {

			for (Company company : setupWindow.companies) {

				if (company.getName().equals(unit.company)) {

					for (Unit secondUnit : company.getUnits()) {

						if (secondUnit.callsign.equals(unit.callsign))
							company.getUnits().set(company.getUnits().indexOf(secondUnit), unit);

					}

				}

			}

		}

		setupWindow.refreshCreated();
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-01 11:46:29.861
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-01 11:46:29.862
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-01 11:46:33.616
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package Conflict;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.Random;

import javax.swing.DefaultListModel;
import javax.swing.JFrame;
import javax.swing.JScrollPane;

import Company.Company;
import CreateGame.SetupWindow;
import HexGrid.HexGrid;
import HexGrid.HexGrid.DeployedUnit;
import Hexes.Hex;
import Hexes.HexWindow;
import Items.PersonalShield;
import Trooper.Trooper;
import Unit.Unit;
import UtilityClasses.HexGridUtility;

import javax.swing.JList;
import javax.swing.JButton;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import java.lang.reflect.Array;

import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.JLabel;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.Toolkit;

import javax.swing.LayoutStyle.ComponentPlacement;

import Actions.Spot;
import Artillery.FireMission;

import javax.swing.JComboBox;
import javax.swing.DefaultComboBoxModel;
import java.awt.event.ItemListener;
import java.awt.event.ItemEvent;
import javax.swing.JSpinner;
import javax.swing.SwingWorker;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

public class GameWindow implements Serializable {
	public static int hexSize = 20;
	public ArrayList<Company> companies;
	public ArrayList<Unit> initiativeOrder = new ArrayList<Unit>();
	public Game game;
	public String visibility = "Good Visibility";
	public ArrayList<Hex> hexes = new ArrayList<Hex>();
	public CloseQuartersBattle cqb = new CloseQuartersBattle(this);
	public ConflictLog conflictLog;
	public static GameWindow gameWindow;

	public SetupWindow setupWindow;
	public JList listIniativeOrder;
	public JFrame f = null;
	public int activeUnit = 0;
	private JLabel lblActiveUnit;
	private JLabel lblRound;
	private JLabel lblPhase;
	private JLabel lblActions;
	public JComboBox comboBoxVisibility;
	private JButton btnStartingSpotTest;
	private JSpinner spinnerInitMod;
	private JComboBox comboBoxInitModSide;
	private JComboBox comboBoxValueMod;
	private JSpinner spinnerValueMod;
	private JSpinner spinnerActiveUnit;
	public HexGrid hexGrid;
	public boolean cqbWindowOpen = false;
	public OpenUnit currentlyOpenUnit;
	private JSpinner spinnerHexSize;
	public int hexCols; 
	public int hexRows; 
	

	/**
	 * Launch the application.
	 */
	public GameWindow(ArrayList<Company> companiesFromSetupWindow, SetupWindow setupWindow, Game game,
			boolean openUnit, int hexRows, int hexCols) {
		this.hexCols = hexCols;
		this.hexRows = hexRows; 
		this.game = game;
		this.gameWindow = this;
		this.conflictLog = new ConflictLog();
		this.setupWindow = setupWindow;
		this.companies = companiesFromSetupWindow;
		conflictLog.addNewLine("     Round: " + game.getRound() + " Phase: " + game.getPhase());
		f = new JFrame("Conflict");
		f.setSize(600, 545);

		// Get the screen size
		Toolkit toolkit = Toolkit.getDefaultToolkit();
		Dimension screenSize = toolkit.getScreenSize();
		// Calculate the frame location
		int x = (screenSize.width - f.getWidth()) / 2;
		int y = (screenSize.height - f.getHeight()) / 2;

		// Set the new frame location
		f.setLocation(x, y);

		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent ev) {
				// frame.dispose();
			}
		});

		JScrollPane scrollPane = new JScrollPane();
		scrollPane.setBounds(10, 196, 564, 302);

		listIniativeOrder = new JList();
		listIniativeOrder.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				Unit unit = initiativeOrder.get(listIniativeOrder.getSelectedIndex());
				// System.out.println("Open unit moral: "+unit.moral);

				if (currentlyOpenUnit != null)
					currentlyOpenUnit.f.dispose();
				currentlyOpenUnit = new OpenUnit(unit, gameWindow, listIniativeOrder.getSelectedIndex());
			}
		});
		scrollPane.setViewportView(listIniativeOrder);

		JButton btnRefreshUnits = new JButton("Add New Units");
		btnRefreshUnits.setBounds(10, 39, 128, 25);
		btnRefreshUnits.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				refreshUnits();

			}
		});

		lblActiveUnit = new JLabel("Active Unit: ");
		lblActiveUnit.setBounds(328, 11, 233, 17);
		lblActiveUnit.setFont(new Font("Calibri", Font.BOLD, 13));

		lblRound = new JLabel("Round:");
		lblRound.setBounds(10, 11, 113, 17);
		lblRound.setFont(new Font("Calibri", Font.BOLD, 13));

		lblPhase = new JLabel("Phase:");
		lblPhase.setBounds(129, 11, 113, 17);
		lblPhase.setFont(new Font("Calibri", Font.BOLD, 13));

		lblActions = new JLabel("Actions:");
		lblActions.setBounds(248, 11, 113, 17);
		lblActions.setFont(new Font("Calibri", Font.BOLD, 13));

		JButton btnD = new JButton("D100");
		btnD.setBounds(148, 40, 69, 23);
		btnD.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {
				Random rand = new Random();
				int roll = rand.nextInt(100) + 1;
				conflictLog.addNewLine("Roll: " + roll);
			}
		});

		comboBoxVisibility = new JComboBox();
		comboBoxVisibility.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {

				visibility = comboBoxVisibility.getSelectedItem().toString();
				game.setDaylightCondition(visibility);

			}
		});
		comboBoxVisibility.setBounds(219, 162, 193, 23);
		comboBoxVisibility.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent arg0) {

			}
		});
		comboBoxVisibility.setModel(new DefaultComboBoxModel(
				new String[] { "Good Visibility", "Dusk", "Night - Full Moon ", "Night - Half Moon", "Night - No Moon",
						"Smoke/Fog/Haze/Overcast", "Dusk - Smoke/Fog/Haze/Overcast", "Night - Smoke/Fog/Haze/Overcast",
						"No Visibility - Heavy Fog - White Out" }));

		JLabel lblVisibility = new JLabel("Visibility:");
		lblVisibility.setBounds(152, 165, 59, 17);
		lblVisibility.setFont(new Font("Calibri", Font.BOLD, 13));

		btnStartingSpotTest = new JButton("General Spot Test");
		btnStartingSpotTest.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
			}
		});
		btnStartingSpotTest.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {

						// System.out.println("Spot1");
						spotCycle();
						// System.out.println("Spot2");
						return null;
					}

					@Override
					protected void done() {

						// System.out.println("Done");
						gameWindow.conflictLog.addQueuedText();
						gameWindow.conflictLog.addNewLine("General Spot Test Completed");
					}

				};

				worker.execute();

			}
		});
		btnStartingSpotTest.setBounds(444, 162, 128, 23);
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

		setInitiativeOrder(companies);
		refreshInitiativeOrder();

		// Sets next active unit
		listIniativeOrder.setSelectedIndex(activeUnit);
		f.getContentPane().setLayout(null);
		f.getContentPane().add(btnStartingSpotTest);
		f.getContentPane().add(scrollPane);
		f.getContentPane().add(lblVisibility);
		f.getContentPane().add(comboBoxVisibility);
		f.getContentPane().add(btnRefreshUnits);
		f.getContentPane().add(lblRound);
		f.getContentPane().add(lblPhase);
		f.getContentPane().add(lblActions);
		f.getContentPane().add(lblActiveUnit);
		f.getContentPane().add(btnD);

		JButton btnNewButton = new JButton("Roll Init Order");
		btnNewButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				setInitiativeOrder(companies);

				for (Unit unit : initiativeOrder) {
					if (unit.side.equals(comboBoxInitModSide.getSelectedItem()))
						unit.initiative += (int) spinnerInitMod.getValue();
				}

				rollInitiativeOrder();
				refreshInitiativeOrder();
			}
		});
		btnNewButton.setBounds(256, 70, 128, 23);
		f.getContentPane().add(btnNewButton);

		JLabel lblInitMod = new JLabel("Init Mod:");
		lblInitMod.setFont(new Font("Calibri", Font.BOLD, 13));
		lblInitMod.setBounds(133, 73, 59, 17);
		f.getContentPane().add(lblInitMod);

		spinnerInitMod = new JSpinner();
		spinnerInitMod.setBounds(202, 71, 44, 20);
		f.getContentPane().add(spinnerInitMod);

		comboBoxInitModSide = new JComboBox();
		comboBoxInitModSide.setModel(new DefaultComboBoxModel(new String[] { "BLUFOR", "OPFOR", "IND" }));
		comboBoxInitModSide.setSelectedIndex(0);
		comboBoxInitModSide.setBounds(48, 68, 75, 23);
		f.getContentPane().add(comboBoxInitModSide);

		JLabel lblSide = new JLabel("Side:");
		lblSide.setFont(new Font("Calibri", Font.BOLD, 13));
		lblSide.setBounds(10, 72, 59, 17);
		f.getContentPane().add(lblSide);

		JLabel lblValueMod = new JLabel("Stat Mod:");
		lblValueMod.setFont(new Font("Calibri", Font.BOLD, 13));
		lblValueMod.setBounds(10, 104, 59, 17);
		f.getContentPane().add(lblValueMod);

		JButton btnNewButton_1 = new JButton("Org.");
		btnNewButton_1.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.organization + (int) spinnerValueMod.getValue() > 100) {
							unit.organization = 100;
						} else {
							unit.organization += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnNewButton_1.setBounds(369, 101, 59, 23);
		f.getContentPane().add(btnNewButton_1);

		JLabel label = new JLabel("Side:");
		label.setFont(new Font("Calibri", Font.BOLD, 13));
		label.setBounds(123, 104, 59, 17);
		f.getContentPane().add(label);

		comboBoxValueMod = new JComboBox();
		comboBoxValueMod.setModel(new DefaultComboBoxModel(new String[] { "BLUFOR", "OPFOR", "IND" }));
		comboBoxValueMod.setBounds(152, 101, 89, 23);
		f.getContentPane().add(comboBoxValueMod);

		JButton btnMorale = new JButton("Mor.");
		btnMorale.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.moral + (int) spinnerValueMod.getValue() > 100) {
							unit.moral = 100;
						} else {
							unit.moral += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnMorale.setBounds(309, 101, 59, 23);
		f.getContentPane().add(btnMorale);

		JButton btnSup = new JButton("Sup.");
		btnSup.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.suppression + (int) spinnerValueMod.getValue() > 100) {
							unit.suppression = 100;
						} else {
							unit.suppression += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnSup.setBounds(248, 101, 59, 23);
		f.getContentPane().add(btnSup);

		spinnerValueMod = new JSpinner();
		spinnerValueMod.setBounds(69, 102, 44, 20);
		f.getContentPane().add(spinnerValueMod);

		JButton btnNewButton_2 = new JButton("Hexes");
		btnNewButton_2.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				new HexWindow(gameWindow);

			}
		});
		btnNewButton_2.setBounds(10, 162, 128, 23);
		f.getContentPane().add(btnNewButton_2);

		JButton btnSet = new JButton("Set");
		btnSet.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
			}
		});
		btnSet.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				activeUnit = (int) spinnerActiveUnit.getValue();
				setUnitlabel();
			}
		});
		btnSet.setBounds(153, 132, 89, 23);
		f.getContentPane().add(btnSet);

		spinnerActiveUnit = new JSpinner();
		spinnerActiveUnit.setBounds(94, 133, 44, 20);
		f.getContentPane().add(spinnerActiveUnit);

		JLabel lblActiveUnit_1 = new JLabel("Active Unit:");
		lblActiveUnit_1.setFont(new Font("Calibri", Font.BOLD, 13));
		lblActiveUnit_1.setBounds(10, 134, 80, 17);
		f.getContentPane().add(lblActiveUnit_1);

		JButton btnClearAllSpotted = new JButton("Clear All Spotted");
		btnClearAllSpotted.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				
				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {

						// System.out.println("Clear Spot1");

						for (Unit unit : initiativeOrder) {

							for (Trooper trooper : unit.individuals) {

								trooper.spotted.clear();

							}

						}

						conflictLog.addNewLine("Cleared spotted.");
						
						// System.out.println("Clear Spot2");
						return null;
					}

				};

				worker.execute();
				
			}
		});
		btnClearAllSpotted.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				

			}
		});
		btnClearAllSpotted.setBounds(444, 132, 128, 23);
		f.getContentPane().add(btnClearAllSpotted);

		JButton btnRefreshCompanyUnits = new JButton("Refresh Company Units");
		btnRefreshCompanyUnits.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				refreshCompanyUnits();

			}

		});
		btnRefreshCompanyUnits.setBounds(231, 39, 165, 25);
		f.getContentPane().add(btnRefreshCompanyUnits);

		JButton btnSkipTo = new JButton("Skip To");
		btnSkipTo.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {
						int originalAU = activeUnit;
						int newActiveUnit = (int) spinnerActiveUnit.getValue();
						
						//System.out.println("Original AU: "+originalAU);
						//System.out.println("Next Active Unit: "+newActiveUnit);
						
						if (newActiveUnit <= originalAU) {

							// Skips to end of init order
							for (int i = originalAU; i < initiativeOrder.size(); i++) {

								try {

									if(newActiveUnit == 0 
											&& newActiveUnit != originalAU 
											&& i == initiativeOrder.size() - 1)
										return null;
									
									safeNextActiveUnit();

								} catch (Exception e2) {
									e2.printStackTrace();
								}

							}
							
							
							
							// skips to active unit
							for (int i = 0; i < newActiveUnit; i++) {

								try {

									safeNextActiveUnit();

								} catch (Exception e2) {
									e2.printStackTrace();
								}

							}

						} else {
							for (int i = originalAU; i < newActiveUnit; i++) {

								/*
								 * for(Trooper trooper : initiativeOrder.get(i).individuals) {
								 * if(game.getPhase() == 1) { trooper.spentPhase1 = game.getCurrentAction(); }
								 * else { trooper.spentPhase2 = game.getCurrentAction(); } }
								 */

								try {

									safeNextActiveUnit();

								} catch (Exception e2) {
									System.out.println("toString(): " + e2.toString());
									System.out.println("getMessage(): " + e2.getMessage());
									System.out.println("StackTrace: ");
									e2.printStackTrace();
								}

							}
						}
						
						return null;
					}

					@Override
					protected void done() {
						conflictLog.addQueuedText();
						guiUpdateNextActiveUnit();

						if(hexGrid != null) {
							hexGrid.panel.shownType = HexGridUtility.getShownTypeFromSide(initiativeOrder.get(activeUnit).side);
						}
						
						openUnit(initiativeOrder.get(activeUnit), activeUnit);
						hexGrid.frame.toFront();
						hexGrid.frame.requestFocus();
					}

				};

				worker.execute();

			}
		});
		btnSkipTo.setBounds(248, 133, 113, 23);
		f.getContentPane().add(btnSkipTo);

		JLabel lblHexSize = new JLabel("Hex Size:");
		lblHexSize.setFont(new Font("Calibri", Font.BOLD, 13));
		lblHexSize.setBounds(406, 41, 59, 17);
		f.getContentPane().add(lblHexSize);

		spinnerHexSize = new JSpinner();
		spinnerHexSize.setBounds(475, 39, 44, 20);
		f.getContentPane().add(spinnerHexSize);

		JButton btnSetHex = new JButton("Set Hex");
		btnSetHex.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {

				hexSize = (int) spinnerHexSize.getValue();
				conflictLog.addNewLine("Hex Size Set To " + hexSize);
			}
		});
		btnSetHex.setBounds(406, 70, 89, 23);
		f.getContentPane().add(btnSetHex);

		// System.out.println("Init order size: "+initiativeOrder.size());
		// Opens active unit
		if (initiativeOrder != null && initiativeOrder.size() > 0) {

			// Updates Lavels
			setUnitlabel();
			setRound();
			setPhase();
			setActions();

			if (openUnit) {
				Unit unit = initiativeOrder.get(activeUnit);
				openUnit(unit, activeUnit);
			}

			// System.out.println("Load Active Unit: "+activeUnit);
		}

		if (game.getDaylightCondition().equals(""))
			comboBoxVisibility.setSelectedIndex(0);

		// Creates hex grid
		// System.out.println("Create hex grid");
		this.hexGrid = new HexGrid(initiativeOrder, gameWindow, hexRows, hexCols);
		if (hexGrid != null && hexGrid.panel.deployedUnits.size() > 0) {
			hexGrid.panel.selectedUnit = hexGrid.panel.deployedUnits.get(activeUnit);
		}

		spinnerHexSize.setValue(hexSize);

		JButton btnNewButton_3 = new JButton("CQB Check");
		btnNewButton_3.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				if (currentlyOpenUnit == null) {
					conflictLog.addNewLine(
							"Use this button at the start of a conflict, specifically when some units are begining the conflict in close quarters battle. "
									+ "Open the first unit in the init order to perform a CQB check.");
					return;
				}

				closeQuartersBattleCheck(currentlyOpenUnit);
			}
		});
		btnNewButton_3.setBounds(444, 101, 128, 23);
		f.getContentPane().add(btnNewButton_3);

	}

	// Opens active unit window
	public void openUnit(Unit unit, int index) {
		// System.out.println("Open unit moral: "+unit.moral);

		try {
			if (currentlyOpenUnit != null)
				currentlyOpenUnit.f.dispose();
			currentlyOpenUnit = new OpenUnit(unit, gameWindow, index);
		} catch (Exception e) {
			System.out.println("toString(): " + e.toString());
			System.out.println("getMessage(): " + e.getMessage());
			System.out.println("StackTrace: ");
			e.printStackTrace();
		}

	}

	// Sets companies equal to the comapny in the setup window
	// Used to save changes made to a company during a conflict
	public void confirmCompany(Company company, int index) {
		setupWindow.setCompany(company, index);
		setupWindow.refreshCreated();
	}

	// Refresh conflict
	public void refreshConflict(SetupWindow setupWindow) {
		this.companies = setupWindow.getActivated();
		rollInitiativeOrder();
		refreshInitiativeOrder();
	}

	public void refreshInitiativeOrder() {
		DefaultListModel initiativeOrderList = new DefaultListModel();

		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Loops through troopers in the unit

			for (int x = 0; x < initiativeOrder.get(i).getSize(); x++) {
				Trooper currentTrooper = initiativeOrder.get(i).getTroopers().get(x);
				currentTrooper.number = x + 1;
			}

			initiativeOrderList.addElement(i + ": " + initiativeOrder.get(i));

		}

		listIniativeOrder.setModel(initiativeOrderList);

		setUnitlabel();
		
		if(hexGrid != null) {
			hexGrid.refreshDeployedUnits();
		}
		
	}

	// Loops through companies
	// Adds units to units array
	// Sets units sides, command value, and initiative
	public void setInitiativeOrder(ArrayList<Company> companies) {
		Random rand = new Random();

		initiativeOrder.clear();

		for (int i = 0; i < companies.size(); i++) {
			Company company = companies.get(i);
			ArrayList<Unit> units = company.getUnits();
			for (int j = 0; j < company.getUnitsLength(); j++) {
				Unit unit = units.get(j);
				// Sets some unit stats
				unit.side = company.getSide();
				unit.company = company.getName();
				unit.getCommandValue();
				int roll = rand.nextInt(10) + 1;
				unit.initiative = roll + unit.commandValue;
				if (unit.active) {
					initiativeOrder.add(unit);
				}

			}
		}

		rollInitiativeOrder();

	}

	// Sets initiative order
	public void rollInitiativeOrder() {

		Unit temp;

		for (int i = 0; i < initiativeOrder.size(); i++) {

			for (int j = 0; j < initiativeOrder.size() - 1; j++) {

				if (initiativeOrder.get(j + 1).initiative > initiativeOrder.get(j).initiative) {
					temp = initiativeOrder.get(j + 1);
					initiativeOrder.set(j + 1, initiativeOrder.get(j));
					initiativeOrder.set(j, temp);

				}
			}
		}

		closeCombatCheck();
		// closeQuartersBattleCheck();
	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void nextActiveUnit() {

		conflictLog.addNewLine("Next unit... Active Unit: " + activeUnit);

		int actions = game.getCurrentAction() + 1;

		// Increases passed active unit members by 1
		if (activeUnit > -1) {
			Unit unit = initiativeOrder.get(activeUnit);
			ArrayList<Trooper> troopers = unit.getTroopers();
			for (int j = 0; j < troopers.size(); j++) {

				// Increases time unconscious
				// Checks for wake up
				if (game.getCurrentAction() <= 3 && game.getCurrentAction() != 0) {

					if (!troopers.get(j).conscious) {

						if (troopers.get(j).timeUnconscious == troopers.get(j).incapacitationTime) {
							troopers.get(j).timeUnconscious = 0;
							troopers.get(j).incapacitationTime = 0;
							conflictLog.addNewLine(troopers.get(j).number + " " + troopers.get(j).name + " from unit:"
									+ unit.callsign + "has awoken.");
							troopers.get(j).conscious = true;
						} else {
							troopers.get(j).timeUnconscious++;
						}

					}

				}

				if (game.getPhase() == 1) {
					if (troopers.get(j).spentPhase1 != actions - 1) {

						if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1)
							troopers.get(j).spentPhase1 += 1;
					}
				} else {
					if (troopers.get(j).spentPhase2 != actions - 1) {

						if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2)
							troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			return;
		}

		int size = initiativeOrder.size();
		size--;

		// If next unit is empty
		// Skips next unit
		// System.out.println("Active Unit: "+activeUnit);
		int unitCount = 1;
		boolean pass = false;
		while (!pass) {

			// Makes sure there is a unit infront of the active unit
			if (activeUnit + unitCount != initiativeOrder.size()) {

				// Checks if the next unit is the last one
				if (activeUnit + 2 == initiativeOrder.size()) {
					// Checks if the last unit is empty
					if (initiativeOrder.get(activeUnit + 1).getSize() < 1) {
						activeUnit = size;
						break;
					}
				}

				// Checks if next unit is empty
				// If unit is alive and not empty
				if (initiativeOrder.get(activeUnit + unitCount).getSize() < 1) {
					// System.out.println("Increase");
					unitCount++;
				} else {

					pass = true;
					activeUnit += unitCount;
					activeUnit--;

				}

				/*
				 * if(activeUnit + unitCount > size || activeUnit > size) { activeUnit = size;
				 * break; }
				 */

				// System.out.println("Modified Active Unit: "+activeUnit);

			} else {
				break;
			}

		}

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		endOfInitOrder(size, actions);

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		openUnit(initiativeOrder.get(activeUnit), activeUnit);

		// Updates Labels
		setUnitlabel();
		setRound();
		setPhase();
		setActions();

	}

	// Performs nessesary checks for twenty seconds of passed time
	public void unitWaitTwentySeconds() {

		int actions = game.getCurrentAction();

		Unit unit = initiativeOrder.get(activeUnit);
		int activeTrooperCount = 0;
		int activeTroopersInCover = 0;
		// Forced Route or Pinned
		for (Trooper trooper : unit.getTroopers()) {

			if (trooper.alive && trooper.conscious) {
				activeTrooperCount++;
				if (trooper.inCover)
					activeTroopersInCover++;
			}

		}

		if (unit.suppression >= 50) {

			if ((double) activeTrooperCount / activeTroopersInCover < 0.5) {
				conflictLog.addNewLine(
						unit.callsign + " is forced to route due to high suppression and minimal cover. This "
								+ "unit can avoid routing if all individuals not in cover can hunker down.");
			} else {
				conflictLog.addNewLine(unit.callsign + " is pinned and cannot move until suppression "
						+ "becomes less than 50. Or a successful command test is made, with one difficulty die for every 10 suppression. "
						+ "And 1 bonus die for each additional leader.");
			}

		}

		// Fire Missions
		for (FireMission fireMission : unit.fireMissions) {
			// System.out.println("Calling Advance Time Fire Mission");
			fireMission.advanceTime();
		}

		ArrayList<Trooper> troopers = unit.getTroopers();
		for (int j = 0; j < troopers.size(); j++) {
			// System.out.println("Pass Trooper: "+j);

			if (!troopers.get(j).alive) {
				troopers.get(j).spentPhase1 = troopers.get(j).P1;
				troopers.get(j).spentPhase2 = troopers.get(j).P2;
				continue;
			}

			// Increases time unconscious
			// Checks for wake up
			if (actions <= 3 && actions != 0) {

				if (!troopers.get(j).conscious) {

					if (troopers.get(j).timeUnconscious >= troopers.get(j).incapacitationTime) {
						troopers.get(j).timeUnconscious = 0;
						troopers.get(j).incapacitationTime = 0;
						conflictLog.addNewLineToQueue(troopers.get(j).number + " " + troopers.get(j).name
								+ " from unit:" + unit.callsign + "has awoken.");
						troopers.get(j).conscious = true;

					} else {
						troopers.get(j).timeUnconscious++;
					}
					troopers.get(j).spentPhase1 = troopers.get(j).P1;
					troopers.get(j).spentPhase2 = troopers.get(j).P2;

					continue;

				}

				Trooper trooper = troopers.get(j);
				if (trooper.personalShield != null) {
					PersonalShield ps = trooper.personalShield;

					if (ps.currentShieldStrength < ps.maxShieldStrength) {

						ps.currentShieldStrength += ps.maxShieldStrength * ps.rechargeRate;

						if (ps.currentShieldStrength > ps.maxShieldStrength)
							ps.currentShieldStrength = ps.maxShieldStrength;

					}

				}

			}

			float time;

			if (gameWindow.game.getPhase() == 1) {
				if (troopers.get(j).P1 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P1;
			} else {
				if (troopers.get(j).P2 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P2;
			}

			if (unit.speed.equals("None")) {
				troopers.get(j).fatigueSystem.AddRecoveryTime(time);
			}

			if (game.getPhase() == 1) {
				if (troopers.get(j).spentPhase1 != actions) {

					if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1) {

						// troopers.get(j).spentPhase1 += 1;
					}
				}
			} else {
				if (troopers.get(j).spentPhase2 != actions) {

					if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2) {

						// troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}
	}

	// Performs nessesary checks for twenty seconds of passed time
	public void unitPassTwentySeconds() {

		int actions = game.getCurrentAction();

		Unit unit = initiativeOrder.get(activeUnit);
		int activeTrooperCount = 0;
		int activeTroopersInCover = 0;
		// Forced Route or Pinned
		for (Trooper trooper : unit.getTroopers()) {

			if (trooper.alive && trooper.conscious) {
				activeTrooperCount++;
				if (trooper.inCover)
					activeTroopersInCover++;
			}

		}

		if (unit.suppression >= 50) {

			if ((double) activeTrooperCount / activeTroopersInCover < 0.5) {
				conflictLog.addNewLine(
						unit.callsign + " is forced to route due to high suppression and minimal cover. This "
								+ "unit can avoid routing if all individuals not in cover can hunker down.");
			} else {
				conflictLog.addNewLine(unit.callsign + " is pinned and cannot move until suppression "
						+ "becomes less than 50. Or a successful command test is made, with one difficulty die for every 10 suppression. "
						+ "And 1 bonus die for each additional leader.");
			}

		}

		// Fire Missions
		for (FireMission fireMission : unit.fireMissions) {
			// System.out.println("Calling Advance Time Fire Mission");
			fireMission.advanceTime();
		}

		ArrayList<Trooper> troopers = unit.getTroopers();
		for (int j = 0; j < troopers.size(); j++) {
			// System.out.println("Pass Trooper: "+j);

			if (!troopers.get(j).alive) {
				troopers.get(j).spentPhase1 = troopers.get(j).P1;
				troopers.get(j).spentPhase2 = troopers.get(j).P2;
				continue;
			}

			// Increases time unconscious
			// Checks for wake up
			if (actions <= 3 && actions != 0) {

				if (!troopers.get(j).conscious) {

					if (troopers.get(j).timeUnconscious >= troopers.get(j).incapacitationTime) {
						troopers.get(j).timeUnconscious = 0;
						troopers.get(j).incapacitationTime = 0;
						conflictLog.addNewLineToQueue(troopers.get(j).number + " " + troopers.get(j).name
								+ " from unit:" + unit.callsign + "has awoken.");
						troopers.get(j).conscious = true;

					} else {
						troopers.get(j).timeUnconscious++;
					}
					troopers.get(j).spentPhase1 = troopers.get(j).P1;
					troopers.get(j).spentPhase2 = troopers.get(j).P2;

					continue;

				}

				Trooper trooper = troopers.get(j);
				if (trooper.personalShield != null) {
					PersonalShield ps = trooper.personalShield;

					if (ps.currentShieldStrength < ps.maxShieldStrength) {

						ps.currentShieldStrength += ps.maxShieldStrength * ps.rechargeRate;

						if (ps.currentShieldStrength > ps.maxShieldStrength)
							ps.currentShieldStrength = ps.maxShieldStrength;

					}

				}

			}

			float time;

			if (gameWindow.game.getPhase() == 1) {
				if (troopers.get(j).P1 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P1;
			} else {
				if (troopers.get(j).P2 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P2;
			}

			// System.out.println("Pass Add Recovery TIme");
			if (unit.speed.equals("None")) {
				troopers.get(j).fatigueSystem.AddRecoveryTime(time);
			}

			if (game.getPhase() == 1) {
				if (troopers.get(j).spentPhase1 != actions) {

					if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1) {

						troopers.get(j).spentPhase1 += 1;
					}
				}
			} else {
				if (troopers.get(j).spentPhase2 != actions) {

					if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2) {

						troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}
	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void safeNextActiveUnit() {
		// System.out.println("\n\nCurrent Action: "+game.getCurrentAction()+" Active
		// Unit: "+activeUnit+"\n\n");

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			// System.out.println("Returning Safe Next Active Unit");
			return;
		}

		unitPassTwentySeconds();

		int size = initiativeOrder.size();
		size--;

		/*
		 * activeUnit++; if(activeUnit == initiativeOrder.size()) activeUnit = 0;
		 */

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		// Might contain gui updates
		// System.out.println("Inside Pass1");
		endOfInitOrder(size, game.getCurrentAction() + 1);

		// System.out.println("Inside Pass2");

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		// listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		// System.out.println("Open Next Active Unit");

	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void safeWaitActiveUnit() {
		// System.out.println("\n\nCurrent Action: "+game.getCurrentAction()+" Active
		// Unit: "+activeUnit+"\n\n");

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			// System.out.println("Returning Safe Next Active Unit");
			return;
		}

		unitWaitTwentySeconds();

		int size = initiativeOrder.size();
		size--;

		/*
		 * activeUnit++; if(activeUnit == initiativeOrder.size()) activeUnit = 0;
		 */

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		// Might contain gui updates
		// System.out.println("Inside Pass1");
		endOfInitOrder(size, game.getCurrentAction() + 1);
		// System.out.println("Inside Pass2");

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		// listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		// System.out.println("Open Next Active Unit");

	}

	public void guiUpdateNextActiveUnit() {

		conflictLog.addNewLine("Next unit... Active Unit: " + activeUnit);

		// Updates Labels
		setUnitlabel();
		setRound();
		setPhase();
		setActions();

	}

	// Takes a trooper, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public static boolean exhaustedTrooper(Trooper trooper) {
		//System.out.println("Exuasted Trooper test: "+trooper.name);
		if (GameWindow.gameWindow.game.getPhase() == 1) {
			if (trooper.spentPhase1 < trooper.P1) {
				//System.out.println("Return False");
				return false;
			}
		} else {
			if (trooper.spentPhase2 < trooper.P2) {
				//System.out.println("Return False");
				return false;
			}
		}
		
		//System.out.println("Return True");
		return true;
	}

	// Takes a unit, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public static boolean exhaustedUnit(Unit unit) {

		// System.out.println("Entering Exhusted Unit Check");

		
		
		for (Trooper trooper : unit.getTroopers()) {
			if(!exhaustedTrooper(trooper))
				return false; 
		}

		// System.out.println("Returning True");
		return true;
	}
	
	public static boolean mostlyExhausted(Unit unit) {
		
		int exausted = 0, fresh = 0;
		
		for (Trooper trooper : unit.getTroopers()) {
			if(exhaustedTrooper(trooper))
				exausted++;
			else 
				fresh++; 
		}

		if(exausted >= fresh) {
			return true;
		} else {
			return false; 
		}
	}

	public static boolean anyoneExhausted(Unit unit) {
		for (Trooper trooper : unit.getTroopers()) {
			if(exhaustedTrooper(trooper))
				return true; 
		}

		// System.out.println("Returning True");
		return false;
	}
	
	// Returns true if all individuals have spent ap for this action, returns false
	// if they have not
	public boolean checkForAllExahusted() {

		for (Unit unit : initiativeOrder) {
			if (!exhaustedUnit(unit))
				return false;
		}

		return true;
	}

	// Takes a unit, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public boolean endActionUnit(Unit unit) {

		// System.out.println("Entering End Action Unit Check");

		for (Trooper trooper : unit.getTroopers()) {
			if (game.getPhase() == 1) {
				if (trooper.spentPhase1 < trooper.P1
						&& trooper.spentPhase1 < GameWindow.gameWindow.game.getCurrentAction()) {
					// System.out.println("Returning False");
					return false;
				}
			} else {
				if (trooper.spentPhase2 < trooper.P2
						&& trooper.spentPhase2 < GameWindow.gameWindow.game.getCurrentAction()) {
					// System.out.println("Returning False");
					return false;
				}
			}
		}

		// System.out.println("Returning True");
		return true;
	}

	// Returns true if all individuals have spent ap for this action, returns false
	// if they have not
	public boolean checkForAllEndAction() {

		for (Unit unit : initiativeOrder) {
			if (!endActionUnit(unit))
				return false;
		}

		return true;
	}

	// Checks and performs tasks for the end of the init order
	public void endOfInitOrder(int size, int actions) {

		boolean endOfPhase = checkForAllExahusted();
		boolean endOfAction = checkForAllEndAction();

		if (endOfPhase) {
			conflictLog.addNewLineToQueue("End of Phase");
			// game.setCurrentAction(actions);
			// conflictLog.addNewLineToQueue("Actions: " + actions);
			// Checks for end of phase
			// Loops through units indiviudals

			// Checks for artillery fire missions
			int diff = 3 - game.getCurrentAction();
			//System.out.println("diff: "+diff);
			for(Unit unit : initiativeOrder) {
				// Fire Missions
				for (FireMission fireMission : unit.fireMissions) {
					// System.out.println("Calling Advance Time Fire Mission");
					for(int i = 0; i < diff; i++) {
						fireMission.advanceTime();						
					}
					
				}
			}
			
			// Check for end of round or phase
			if (game.getPhase() == 1) {
				game.setPhase(2);
				// End of phase
				conflictLog.addNewLineToQueue("     Round: " + game.getRound() + " Phase: 2");
				endOfPhase();
			} else {
				game.setPhase(1);
				int round = game.getRound() + 1;
				game.setRound(round);
				conflictLog.addNewLineToQueue("     Round: " + game.getRound() + " Phase: 1");
				// End of round
				endOfPhase();
				endOfRound();

			}

			activeUnit = 0;
		} else if (endOfAction) {
			game.setCurrentAction(actions);
			conflictLog.addNewLineToQueue("End of Action");
			conflictLog.addNewLineToQueue("Actions: " + actions);
			activeUnit = 0;
			
			//System.out.println("End of action");
			
			// Action ended 
			for(DeployedUnit deployedUnit : hexGrid.panel.deployedUnits) {
				deployedUnit.moved = false; 
			}
			
			int currentAction = game.getCurrentAction();
			// Performs spot test
			if (currentAction == 1 || currentAction == 2 || currentAction == 3)
				spotCycle();

		} else if (activeUnit >= size) {

			for (int i = 0; i < initiativeOrder.size(); i++) {

				if (!endActionUnit(initiativeOrder.get(i))) {
					activeUnit = i;
					break;
				}

			}
			
			
			

		} else {
			activeUnit++;
		}
		

	}

	public void closeQuartersBattleCheck(OpenUnit openUnit) {

		cqb.closeQuartersBattleCheck(openUnit);

	}

	// Sets active unit label
	public void setUnitlabel() {
		if (initiativeOrder == null || initiativeOrder.size() < 1)
			return;
		else if (activeUnit > initiativeOrder.size())
			return;
		else if (activeUnit >= initiativeOrder.size()) {
			activeUnit = 0;
			return;
		} else if (initiativeOrder.get(activeUnit) == null)
			return;

		lblActiveUnit.setText("Active Unit: " + initiativeOrder.get(activeUnit).side + "::  "
				+ initiativeOrder.get(activeUnit).callsign);
	}

	// Set round
	public void setRound() {
		lblRound.setText("Round: " + game.getRound());
	}

	// Set phase
	public void setPhase() {
		lblPhase.setText("Phase: " + game.getPhase());

	}

	// Set actions
	public void setActions() {
		lblActions.setText("Actions: " + game.getCurrentAction());
	}

	// End of round
	// Loops through initiative order
	// Resets each troopers spentPhase AP to 0
	// Checks if a trooper is unconscious
	// If the trooper is unconscious increases the time unconscious by two minutes
	// Performs wake up tests is applicable
	public void endOfRound() {
		game.setCurrentAction(1);
		Random rand = new Random();

		// Loops through initiative order order
		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Gets current unit
			Unit unit = initiativeOrder.get(i);

			if (unit.behavior.equals("Recent Contact")) {
				unit.timeSinceContact += 1;

			}

			/*
			 * if(unit.timeSinceContact >= 5) { unit.behavior = "No Contact";
			 * unit.timeSinceContact = 0; }
			 */

			// Gets troopers
			ArrayList<Trooper> troopers = unit.getTroopers();

			// Loops through troopers
			for (int j = 0; j < unit.getSize(); j++) {
				Trooper trooper = troopers.get(j);
				// int TN = trooper.endurance;
				// Resets spent ap
				trooper.spentPhase1 = 0;
				trooper.spentPhase2 = 0;

				// Checks if trooper is conscious
				if (!trooper.conscious) {
					/*
					 * // Increases time spent unconscious trooper.timeUnconscious += 2;
					 * 
					 * // Performs wake up tests
					 * 
					 * 
					 * 
					 * if(trooper.timeUnconscious >= 14 && trooper.currentHP > 0) {
					 * trooper.conscious = true;
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has woken up..."); trooper.timeUnconscious = 0; }
					 * 
					 * 
					 * 
					 * int roll = rand.nextInt(100) + 1;
					 * 
					 * if(trooper.currentHP < -1 * trooper.hp) { if(trooper.timeUnconscious >= 718)
					 * { if(roll > TN) {
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has died of their injuries..."); trooper.alive = false; } } } else
					 * if(trooper.currentHP < 1) { if(trooper.timeUnconscious >= 58) { if(roll <=
					 * TN) {
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has woken up..."); trooper.conscious = true; trooper.timeUnconscious
					 * = 0; } } }
					 */

				}

				// Checks if trooper is mortally wounded
				/*
				 * if(trooper.mortallyWounded) { // Increases time spent mortally wounded
				 * trooper.timeMortallyWounded += 2;
				 * 
				 * // Checks if mortal wound is stabalized, makes rolls once per hour // If the
				 * character is not stablaized then rolls occur every half hour
				 * if(trooper.timeMortallyWounded >= 58 && trooper.stabalized) { int tempTN;
				 * 
				 * int skill = trooper.physicianSkill;
				 * 
				 * if(skill > TN) { tempTN = skill; } else { tempTN = TN; }
				 * 
				 * int roll = rand.nextInt(100) + 1; if(roll > tempTN) { trooper.alive = false;
				 * conflictLog.addNewLineToQueue(unit.callsign+":: "+trooper.name+", Number: "
				 * +trooper.number+" has died of their injuries..."); }
				 * 
				 * } else if(trooper.timeMortallyWounded >= 28) { int roll = rand.nextInt(100) +
				 * 1; if(roll > TN) { trooper.alive = false;
				 * conflictLog.addNewLineToQueue(unit.callsign+":: "+trooper.name+", Number: "
				 * +trooper.number+" has died of their injuries..."); } }
				 * 
				 * }
				 */

			}
		}
	}

	// End of phase

	public void endOfPhase() {

		// Loops through all individuals, increases time passed for wounds
		// Checks unit morale, forces individuals to hunker down that are subject to the
		// morale failure

		for (int i = 0; i < initiativeOrder.size(); i++) {

			for (int x = 0; x < initiativeOrder.get(i).getSize(); x++) {

				if (initiativeOrder.get(i).moral < 30) {
					Random rand = new Random();
					int roll = rand.nextInt(10) + 1;

					if (roll < initiativeOrder.get(i).getTroopers().get(x).P1
							+ initiativeOrder.get(i).getTroopers().get(x).P2) {

						if (initiativeOrder.get(i).getTroopers().get(x).inCover) {
							initiativeOrder.get(i).getTroopers().get(x).HD = true;
							conflictLog.addNewLineToQueue(initiativeOrder.get(i).getTroopers().get(x).number + " "
									+ initiativeOrder.get(i).getTroopers().get(x).name
									+ " hunkers down. Morale too low.");
						}

					}

				}

				initiativeOrder.get(i).getTroopers().get(x).advanceTime(this, conflictLog);
			}

		}

		for (int i = 0; i < initiativeOrder.size(); i++) {
			if (initiativeOrder.get(i).suppression - 10 > 0) {
				initiativeOrder.get(i).suppression -= 5;
			} else {
				initiativeOrder.get(i).suppression = 0;
			}

			if (initiativeOrder.get(i).behavior.equals("No Contact")) {
				initiativeOrder.get(i).organization += initiativeOrder.get(i).commandValue
						+ (initiativeOrder.get(i).moral / 20);
			} else if (initiativeOrder.get(i).behavior.equals("Recent Contact")) {
				initiativeOrder.get(i).organization += initiativeOrder.get(i).commandValue
						+ (initiativeOrder.get(i).moral / 20) / 2;
			}

			if (initiativeOrder.get(i).organization > 100) {

				initiativeOrder.get(i).organization = 100;

			}
		}

		// Loops through initiative order order
		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Gets current unit
			Unit unit = initiativeOrder.get(i);
			// Gets troopers
			ArrayList<Trooper> troopers = unit.getTroopers();

			// Loops through troopers
			for (int j = 0; j < unit.getSize(); j++) {
				Trooper trooper = troopers.get(j);

				// Checks for shields
				// Recharges sheilds
				if (trooper.shields > 0) {
					trooper.currentShields = trooper.shields;
				}

			}

		}

		game.setCurrentAction(1);

	}

	// Loops through each unit
	// Rolls spot for all individuals against units that are not on their side
	public void spotCycle() {

		for (Iterator<Unit> iteratorInitOrder = initiativeOrder.iterator(); iteratorInitOrder.hasNext();) {

			Unit spotterUnit = iteratorInitOrder.next();
			// System.out.println("Spotter Unit: "+spotterUnit);

			for (Iterator<Trooper> troopers = spotterUnit.individuals.iterator(); troopers.hasNext();) {
				Trooper spotterTrooper = troopers.next();
				// System.out.println("Spotter Trooper: "+spotterTrooper.name);
				for (Iterator<Unit> targetUnits = spotterUnit.lineOfSight.iterator(); targetUnits.hasNext();) {

					Unit targetUnit = targetUnits.next();
					// System.out.println("Target Unit: "+targetUnit.callsign);
					// System.out.println("Entering Spot 1");
					spot(targetUnit, spotterUnit, spotterTrooper);
					// System.out.println("Exiting Spot 2");
				}

			}

		}

		/*
		 * for (int i = 0; i < initiativeOrder.size(); i++) { // Gets spotter unit Unit
		 * spotterUnit = initiativeOrder.get(i);
		 * 
		 * // Loops through troopers for(int x = 0; x <
		 * spotterUnit.getTroopers().size(); x++) {
		 * 
		 * // Clears trooper's spot spotterUnit.getTroopers().get(x).spotted.clear();
		 * 
		 * // Loops through units a second time for (int j = 0; j <
		 * initiativeOrder.size(); j++) {
		 * 
		 * // If not the same unit if(!initiativeOrder.get(j).compareTo(spotterUnit) &&
		 * !initiativeOrder.get(j).side.equals(spotterUnit.side)) {
		 * 
		 * 
		 * // Performs spot test spot(initiativeOrder.get(j), spotterUnit,
		 * spotterUnit.getTroopers().get(x));
		 * 
		 * 
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 */

	}

	// Creates new spot action and adds it to trooper
	public void spot(Unit targetUnit, Unit spotterUnit, Trooper trooper) {
		// System.out.println("Target Unit: "+targetUnit.callsign);
		// System.out.println("spotterUnit: "+spotterUnit.callsign);

		for (Unit unit : spotterUnit.lineOfSight) {
			// System.out.println("Unit in LOS: "+unit.callsign);
		}

		// System.out.println("spotterUnitLOS: "+spotterUnit.lineOfSight);
		if (!spotterUnit.lineOfSight.contains(targetUnit)) {
			// System.out.println("No LOS to Units: Spotter Unit: "+spotterUnit.callsign+",
			// targetUnit: "+targetUnit.callsign);
			return;
		}

		// System.out.println("New Spot Action 1");
		Spot spotAction = new Spot(gameWindow, spotterUnit, targetUnit, trooper, "180 Degrees", gameWindow.visibility,
				gameWindow.initiativeOrder, gameWindow);
		// System.out.println("New Spot Action 2");
		// Set results in trooper
		trooper.spotted.add(spotAction);
		// System.out.println("New Spot Action 3");
	}

	// Takes units from companies not already in the init order
	// Makes an init roll
	public void refreshUnits() {

		Random rand = new Random();

		ArrayList<Company> companies = setupWindow.getActivated();

		for (int i = 0; i < companies.size(); i++) {
			Company company = companies.get(i);
			ArrayList<Unit> units = company.getUnits();
			for (int j = 0; j < company.getUnitsLength(); j++) {
				Unit unit = units.get(j);

				boolean alreadyExists = false;
				for (Unit initUnit : initiativeOrder) {
					if (unit.callsign.equals(initUnit.callsign))
						alreadyExists = true;
				}

				if (!alreadyExists) {
					// Sets some unit stats
					unit.side = company.getSide();
					unit.company = company.getName();
					unit.getCommandValue();

					if (game.getPhase() == 1) {
						for (Trooper trooper : unit.getTroopers()) {

							trooper.spentPhase1 = game.getCurrentAction() - 1;

							if (game.getCurrentAction() == 1)
								trooper.spentPhase1 = 0;

						}
					} else {
						for (Trooper trooper : unit.getTroopers()) {

							trooper.spentPhase1 = trooper.P1;
							trooper.spentPhase2 = game.getCurrentAction() - 1;

							if (game.getCurrentAction() == 1)
								trooper.spentPhase2 = 0;

						}
					}

					int roll = rand.nextInt(10) + 1;

					unit.initiative = roll + unit.commandValue;
					if (unit.active) {
						initiativeOrder.add(unit);
					}
				}

			}
		}

		// Removes deactivated units
		/*
		 * for(Unit unit : initiativeOrder) {
		 * 
		 * if(!unit.active) {
		 * 
		 * initiativeOrder.remove(unit);
		 * 
		 * }
		 * 
		 * }
		 */

		// rollInitiativeOrder();
		refreshInitiativeOrder();

	}

	// Loops through all units in the iniiative order, checks if close combat should
	// be initaited
	public void closeCombatCheck() {

		int size = initiativeOrder.size();

		for (int i = 0; i < size; i++) {

			Unit unit = initiativeOrder.get(i);
			boolean closeCombat = false;

			ArrayList<Trooper> flee = new ArrayList<>();
			boolean rout = false;

			for (int x = 0; x < size; x++) {

				Unit unit2 = initiativeOrder.get(x);

				if (!unit.compareTo(unit2)) {

					if (unit.X == unit2.X && unit.Y == unit2.Y && !unit.side.equals(unit2.side)) {
						closeCombat = true;
						Random rand = new Random();

						if (!unit.closeCombat) {
							unit.closeCombat = true;

							if (unit.individuals.size() > 0) {

								int leaderShipRoll = rand.nextInt(100) + 1;

								// System.out.println("LR Roll 1: "+leaderShipRoll);

								if (unit.moral < 60) {
									int margin = 60 - unit.moral;
									margin = margin / 10;
									leaderShipRoll += margin * 10;

								}

								// System.out.println("LR Roll Modded: "+leaderShipRoll);

								gameWindow.conflictLog.addNewLine("Entering Close Combat: " + unit.callsign);
								gameWindow.conflictLog.addNewLine("Command: " + unit.individuals.get(0).command);
								gameWindow.conflictLog.addNewLine("Leadership Roll: " + leaderShipRoll);
								gameWindow.conflictLog.addNewLine("Unit Morale: " + unit.moral);

								if (leaderShipRoll > unit.individuals.get(0).command) {
									for (int j = 0; j < unit.individuals.size(); j++) {
										int roll = rand.nextInt(100) + 1;
										gameWindow.conflictLog.addNewLine(unit.individuals.get(j).name + " "
												+ unit.individuals.get(j).number + " Morale Roll: " + roll);

										if (roll > unit.moral) {
											flee.add(unit.individuals.get(j));
											rout = true;

										}
									}
								}
							}

						}

					}

				}

			}
			if (!closeCombat) {
				unit.closeCombat = false;
			}

			if (rout) {
				unit.flee(gameWindow, unit, flee);
			}

		}

	}

	// Targets X and Y, returns hex
	public Hex findHex(int x, int y) {

		for (Hex hex : hexes) {
			if (hex.xCord == x && hex.yCord == y)
				return hex;
		}

		return null;

	}

	// Finds the differance between the two locations
	public static int hexDif(Unit targetUnit, Unit shooterUnit) {
		return hexDif(targetUnit.X, targetUnit.Y, shooterUnit.X, shooterUnit.Y);
	}

	// Finds the differance between the two locations
	public static int hexDif(int x, int y, Unit shooterUnit) {
		return hexDif(x, y, shooterUnit.X, shooterUnit.Y);
	}

	public static int hexDif(int x, int y, int x1, int y1) {
		return dist(x, y, x1, y1);
	}
	
	public static int dist(int x1, int x2, int y1, int y2) {
		
		int du = x2 - x1;
		int dv = Math.floorDiv(y2 + x2)(y2 + x2 / 2)
		
		
	}
	
	
	public ArrayList<Unit> getUnitsInHex(String sideSpecified, int x, int y) {

		ArrayList<Unit> units = new ArrayList<>();

		for (Unit unit : initiativeOrder) {
			if (unit.X != x || unit.Y != y)
				continue;

			if (unit.side.equals(sideSpecified) || (sideSpecified.equals("") || sideSpecified.equals("None"))) {
				units.add(unit);
			}
		}

		return units;
	}

	public ArrayList<Unit> getUnitsInHexExcludingSide(String sideSpecified, int x, int y) {

		ArrayList<Unit> units = new ArrayList<>();

		for (Unit unit : initiativeOrder) {
			if (unit.X != x || unit.Y != y)
				continue;

			// System.out.println("Add unit");
			if (!unit.side.equals(sideSpecified) || (sideSpecified.equals("") || sideSpecified.equals("None"))) {
				units.add(unit);
			}
		}

		return units;
	}

	public static String getLogHead(Trooper target) {
		return GameWindow.findTrooperUnit(target).callsign + ", " + target.number + ": " + target.name;
	}

	public static void addTrooperEntryToLog(Trooper trooper, String text) {
		GameWindow.gameWindow.conflictLog.addNewLineToQueue(GameWindow.gameWindow.getLogHead(trooper) + " " + text);
	}

	// Loops through units in initiaitive order
	// Looks for unit containing indvididual
	// Returns unit
	public static Unit findTrooperUnit(Trooper trooper) {
		ArrayList<Unit> units = gameWindow.initiativeOrder;

		for (Unit unit : units) {

			for (Trooper trooper1 : unit.getTroopers()) {

				if (trooper1.compareTo(trooper))
					return unit;

			}

		}

		return null;

	}

	public void randomEventCheck() {
		Random rand = new Random();

		if (rand.nextInt(100) + 1 < 5) {
			conflictLog.addNewLine("Random Event Has Occured");
		}

	}

	public void refreshCompanyUnits() {
		// Auto-generated method stub
		conflictLog.addNewLine("Refreshed Units");

		for (Unit unit : initiativeOrder) {

			for (Company company : setupWindow.companies) {

				if (company.getName().equals(unit.company)) {

					for (Unit secondUnit : company.getUnits()) {

						if (secondUnit.callsign.equals(unit.callsign))
							company.getUnits().set(company.getUnits().indexOf(secondUnit), unit);

					}

				}

			}

		}

		setupWindow.refreshCreated();
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-01 11:46:33.617
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-01 11:46:33.617
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-01 11:46:34.278
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package Conflict;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.Random;

import javax.swing.DefaultListModel;
import javax.swing.JFrame;
import javax.swing.JScrollPane;

import Company.Company;
import CreateGame.SetupWindow;
import HexGrid.HexGrid;
import HexGrid.HexGrid.DeployedUnit;
import Hexes.Hex;
import Hexes.HexWindow;
import Items.PersonalShield;
import Trooper.Trooper;
import Unit.Unit;
import UtilityClasses.HexGridUtility;

import javax.swing.JList;
import javax.swing.JButton;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import java.lang.reflect.Array;

import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.JLabel;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.Toolkit;

import javax.swing.LayoutStyle.ComponentPlacement;

import Actions.Spot;
import Artillery.FireMission;

import javax.swing.JComboBox;
import javax.swing.DefaultComboBoxModel;
import java.awt.event.ItemListener;
import java.awt.event.ItemEvent;
import javax.swing.JSpinner;
import javax.swing.SwingWorker;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

public class GameWindow implements Serializable {
	public static int hexSize = 20;
	public ArrayList<Company> companies;
	public ArrayList<Unit> initiativeOrder = new ArrayList<Unit>();
	public Game game;
	public String visibility = "Good Visibility";
	public ArrayList<Hex> hexes = new ArrayList<Hex>();
	public CloseQuartersBattle cqb = new CloseQuartersBattle(this);
	public ConflictLog conflictLog;
	public static GameWindow gameWindow;

	public SetupWindow setupWindow;
	public JList listIniativeOrder;
	public JFrame f = null;
	public int activeUnit = 0;
	private JLabel lblActiveUnit;
	private JLabel lblRound;
	private JLabel lblPhase;
	private JLabel lblActions;
	public JComboBox comboBoxVisibility;
	private JButton btnStartingSpotTest;
	private JSpinner spinnerInitMod;
	private JComboBox comboBoxInitModSide;
	private JComboBox comboBoxValueMod;
	private JSpinner spinnerValueMod;
	private JSpinner spinnerActiveUnit;
	public HexGrid hexGrid;
	public boolean cqbWindowOpen = false;
	public OpenUnit currentlyOpenUnit;
	private JSpinner spinnerHexSize;
	public int hexCols; 
	public int hexRows; 
	

	/**
	 * Launch the application.
	 */
	public GameWindow(ArrayList<Company> companiesFromSetupWindow, SetupWindow setupWindow, Game game,
			boolean openUnit, int hexRows, int hexCols) {
		this.hexCols = hexCols;
		this.hexRows = hexRows; 
		this.game = game;
		this.gameWindow = this;
		this.conflictLog = new ConflictLog();
		this.setupWindow = setupWindow;
		this.companies = companiesFromSetupWindow;
		conflictLog.addNewLine("     Round: " + game.getRound() + " Phase: " + game.getPhase());
		f = new JFrame("Conflict");
		f.setSize(600, 545);

		// Get the screen size
		Toolkit toolkit = Toolkit.getDefaultToolkit();
		Dimension screenSize = toolkit.getScreenSize();
		// Calculate the frame location
		int x = (screenSize.width - f.getWidth()) / 2;
		int y = (screenSize.height - f.getHeight()) / 2;

		// Set the new frame location
		f.setLocation(x, y);

		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent ev) {
				// frame.dispose();
			}
		});

		JScrollPane scrollPane = new JScrollPane();
		scrollPane.setBounds(10, 196, 564, 302);

		listIniativeOrder = new JList();
		listIniativeOrder.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				Unit unit = initiativeOrder.get(listIniativeOrder.getSelectedIndex());
				// System.out.println("Open unit moral: "+unit.moral);

				if (currentlyOpenUnit != null)
					currentlyOpenUnit.f.dispose();
				currentlyOpenUnit = new OpenUnit(unit, gameWindow, listIniativeOrder.getSelectedIndex());
			}
		});
		scrollPane.setViewportView(listIniativeOrder);

		JButton btnRefreshUnits = new JButton("Add New Units");
		btnRefreshUnits.setBounds(10, 39, 128, 25);
		btnRefreshUnits.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				refreshUnits();

			}
		});

		lblActiveUnit = new JLabel("Active Unit: ");
		lblActiveUnit.setBounds(328, 11, 233, 17);
		lblActiveUnit.setFont(new Font("Calibri", Font.BOLD, 13));

		lblRound = new JLabel("Round:");
		lblRound.setBounds(10, 11, 113, 17);
		lblRound.setFont(new Font("Calibri", Font.BOLD, 13));

		lblPhase = new JLabel("Phase:");
		lblPhase.setBounds(129, 11, 113, 17);
		lblPhase.setFont(new Font("Calibri", Font.BOLD, 13));

		lblActions = new JLabel("Actions:");
		lblActions.setBounds(248, 11, 113, 17);
		lblActions.setFont(new Font("Calibri", Font.BOLD, 13));

		JButton btnD = new JButton("D100");
		btnD.setBounds(148, 40, 69, 23);
		btnD.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {
				Random rand = new Random();
				int roll = rand.nextInt(100) + 1;
				conflictLog.addNewLine("Roll: " + roll);
			}
		});

		comboBoxVisibility = new JComboBox();
		comboBoxVisibility.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {

				visibility = comboBoxVisibility.getSelectedItem().toString();
				game.setDaylightCondition(visibility);

			}
		});
		comboBoxVisibility.setBounds(219, 162, 193, 23);
		comboBoxVisibility.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent arg0) {

			}
		});
		comboBoxVisibility.setModel(new DefaultComboBoxModel(
				new String[] { "Good Visibility", "Dusk", "Night - Full Moon ", "Night - Half Moon", "Night - No Moon",
						"Smoke/Fog/Haze/Overcast", "Dusk - Smoke/Fog/Haze/Overcast", "Night - Smoke/Fog/Haze/Overcast",
						"No Visibility - Heavy Fog - White Out" }));

		JLabel lblVisibility = new JLabel("Visibility:");
		lblVisibility.setBounds(152, 165, 59, 17);
		lblVisibility.setFont(new Font("Calibri", Font.BOLD, 13));

		btnStartingSpotTest = new JButton("General Spot Test");
		btnStartingSpotTest.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
			}
		});
		btnStartingSpotTest.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {

						// System.out.println("Spot1");
						spotCycle();
						// System.out.println("Spot2");
						return null;
					}

					@Override
					protected void done() {

						// System.out.println("Done");
						gameWindow.conflictLog.addQueuedText();
						gameWindow.conflictLog.addNewLine("General Spot Test Completed");
					}

				};

				worker.execute();

			}
		});
		btnStartingSpotTest.setBounds(444, 162, 128, 23);
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

		setInitiativeOrder(companies);
		refreshInitiativeOrder();

		// Sets next active unit
		listIniativeOrder.setSelectedIndex(activeUnit);
		f.getContentPane().setLayout(null);
		f.getContentPane().add(btnStartingSpotTest);
		f.getContentPane().add(scrollPane);
		f.getContentPane().add(lblVisibility);
		f.getContentPane().add(comboBoxVisibility);
		f.getContentPane().add(btnRefreshUnits);
		f.getContentPane().add(lblRound);
		f.getContentPane().add(lblPhase);
		f.getContentPane().add(lblActions);
		f.getContentPane().add(lblActiveUnit);
		f.getContentPane().add(btnD);

		JButton btnNewButton = new JButton("Roll Init Order");
		btnNewButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				setInitiativeOrder(companies);

				for (Unit unit : initiativeOrder) {
					if (unit.side.equals(comboBoxInitModSide.getSelectedItem()))
						unit.initiative += (int) spinnerInitMod.getValue();
				}

				rollInitiativeOrder();
				refreshInitiativeOrder();
			}
		});
		btnNewButton.setBounds(256, 70, 128, 23);
		f.getContentPane().add(btnNewButton);

		JLabel lblInitMod = new JLabel("Init Mod:");
		lblInitMod.setFont(new Font("Calibri", Font.BOLD, 13));
		lblInitMod.setBounds(133, 73, 59, 17);
		f.getContentPane().add(lblInitMod);

		spinnerInitMod = new JSpinner();
		spinnerInitMod.setBounds(202, 71, 44, 20);
		f.getContentPane().add(spinnerInitMod);

		comboBoxInitModSide = new JComboBox();
		comboBoxInitModSide.setModel(new DefaultComboBoxModel(new String[] { "BLUFOR", "OPFOR", "IND" }));
		comboBoxInitModSide.setSelectedIndex(0);
		comboBoxInitModSide.setBounds(48, 68, 75, 23);
		f.getContentPane().add(comboBoxInitModSide);

		JLabel lblSide = new JLabel("Side:");
		lblSide.setFont(new Font("Calibri", Font.BOLD, 13));
		lblSide.setBounds(10, 72, 59, 17);
		f.getContentPane().add(lblSide);

		JLabel lblValueMod = new JLabel("Stat Mod:");
		lblValueMod.setFont(new Font("Calibri", Font.BOLD, 13));
		lblValueMod.setBounds(10, 104, 59, 17);
		f.getContentPane().add(lblValueMod);

		JButton btnNewButton_1 = new JButton("Org.");
		btnNewButton_1.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.organization + (int) spinnerValueMod.getValue() > 100) {
							unit.organization = 100;
						} else {
							unit.organization += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnNewButton_1.setBounds(369, 101, 59, 23);
		f.getContentPane().add(btnNewButton_1);

		JLabel label = new JLabel("Side:");
		label.setFont(new Font("Calibri", Font.BOLD, 13));
		label.setBounds(123, 104, 59, 17);
		f.getContentPane().add(label);

		comboBoxValueMod = new JComboBox();
		comboBoxValueMod.setModel(new DefaultComboBoxModel(new String[] { "BLUFOR", "OPFOR", "IND" }));
		comboBoxValueMod.setBounds(152, 101, 89, 23);
		f.getContentPane().add(comboBoxValueMod);

		JButton btnMorale = new JButton("Mor.");
		btnMorale.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.moral + (int) spinnerValueMod.getValue() > 100) {
							unit.moral = 100;
						} else {
							unit.moral += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnMorale.setBounds(309, 101, 59, 23);
		f.getContentPane().add(btnMorale);

		JButton btnSup = new JButton("Sup.");
		btnSup.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.suppression + (int) spinnerValueMod.getValue() > 100) {
							unit.suppression = 100;
						} else {
							unit.suppression += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnSup.setBounds(248, 101, 59, 23);
		f.getContentPane().add(btnSup);

		spinnerValueMod = new JSpinner();
		spinnerValueMod.setBounds(69, 102, 44, 20);
		f.getContentPane().add(spinnerValueMod);

		JButton btnNewButton_2 = new JButton("Hexes");
		btnNewButton_2.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				new HexWindow(gameWindow);

			}
		});
		btnNewButton_2.setBounds(10, 162, 128, 23);
		f.getContentPane().add(btnNewButton_2);

		JButton btnSet = new JButton("Set");
		btnSet.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
			}
		});
		btnSet.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				activeUnit = (int) spinnerActiveUnit.getValue();
				setUnitlabel();
			}
		});
		btnSet.setBounds(153, 132, 89, 23);
		f.getContentPane().add(btnSet);

		spinnerActiveUnit = new JSpinner();
		spinnerActiveUnit.setBounds(94, 133, 44, 20);
		f.getContentPane().add(spinnerActiveUnit);

		JLabel lblActiveUnit_1 = new JLabel("Active Unit:");
		lblActiveUnit_1.setFont(new Font("Calibri", Font.BOLD, 13));
		lblActiveUnit_1.setBounds(10, 134, 80, 17);
		f.getContentPane().add(lblActiveUnit_1);

		JButton btnClearAllSpotted = new JButton("Clear All Spotted");
		btnClearAllSpotted.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				
				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {

						// System.out.println("Clear Spot1");

						for (Unit unit : initiativeOrder) {

							for (Trooper trooper : unit.individuals) {

								trooper.spotted.clear();

							}

						}

						conflictLog.addNewLine("Cleared spotted.");
						
						// System.out.println("Clear Spot2");
						return null;
					}

				};

				worker.execute();
				
			}
		});
		btnClearAllSpotted.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				

			}
		});
		btnClearAllSpotted.setBounds(444, 132, 128, 23);
		f.getContentPane().add(btnClearAllSpotted);

		JButton btnRefreshCompanyUnits = new JButton("Refresh Company Units");
		btnRefreshCompanyUnits.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				refreshCompanyUnits();

			}

		});
		btnRefreshCompanyUnits.setBounds(231, 39, 165, 25);
		f.getContentPane().add(btnRefreshCompanyUnits);

		JButton btnSkipTo = new JButton("Skip To");
		btnSkipTo.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {
						int originalAU = activeUnit;
						int newActiveUnit = (int) spinnerActiveUnit.getValue();
						
						//System.out.println("Original AU: "+originalAU);
						//System.out.println("Next Active Unit: "+newActiveUnit);
						
						if (newActiveUnit <= originalAU) {

							// Skips to end of init order
							for (int i = originalAU; i < initiativeOrder.size(); i++) {

								try {

									if(newActiveUnit == 0 
											&& newActiveUnit != originalAU 
											&& i == initiativeOrder.size() - 1)
										return null;
									
									safeNextActiveUnit();

								} catch (Exception e2) {
									e2.printStackTrace();
								}

							}
							
							
							
							// skips to active unit
							for (int i = 0; i < newActiveUnit; i++) {

								try {

									safeNextActiveUnit();

								} catch (Exception e2) {
									e2.printStackTrace();
								}

							}

						} else {
							for (int i = originalAU; i < newActiveUnit; i++) {

								/*
								 * for(Trooper trooper : initiativeOrder.get(i).individuals) {
								 * if(game.getPhase() == 1) { trooper.spentPhase1 = game.getCurrentAction(); }
								 * else { trooper.spentPhase2 = game.getCurrentAction(); } }
								 */

								try {

									safeNextActiveUnit();

								} catch (Exception e2) {
									System.out.println("toString(): " + e2.toString());
									System.out.println("getMessage(): " + e2.getMessage());
									System.out.println("StackTrace: ");
									e2.printStackTrace();
								}

							}
						}
						
						return null;
					}

					@Override
					protected void done() {
						conflictLog.addQueuedText();
						guiUpdateNextActiveUnit();

						if(hexGrid != null) {
							hexGrid.panel.shownType = HexGridUtility.getShownTypeFromSide(initiativeOrder.get(activeUnit).side);
						}
						
						openUnit(initiativeOrder.get(activeUnit), activeUnit);
						hexGrid.frame.toFront();
						hexGrid.frame.requestFocus();
					}

				};

				worker.execute();

			}
		});
		btnSkipTo.setBounds(248, 133, 113, 23);
		f.getContentPane().add(btnSkipTo);

		JLabel lblHexSize = new JLabel("Hex Size:");
		lblHexSize.setFont(new Font("Calibri", Font.BOLD, 13));
		lblHexSize.setBounds(406, 41, 59, 17);
		f.getContentPane().add(lblHexSize);

		spinnerHexSize = new JSpinner();
		spinnerHexSize.setBounds(475, 39, 44, 20);
		f.getContentPane().add(spinnerHexSize);

		JButton btnSetHex = new JButton("Set Hex");
		btnSetHex.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {

				hexSize = (int) spinnerHexSize.getValue();
				conflictLog.addNewLine("Hex Size Set To " + hexSize);
			}
		});
		btnSetHex.setBounds(406, 70, 89, 23);
		f.getContentPane().add(btnSetHex);

		// System.out.println("Init order size: "+initiativeOrder.size());
		// Opens active unit
		if (initiativeOrder != null && initiativeOrder.size() > 0) {

			// Updates Lavels
			setUnitlabel();
			setRound();
			setPhase();
			setActions();

			if (openUnit) {
				Unit unit = initiativeOrder.get(activeUnit);
				openUnit(unit, activeUnit);
			}

			// System.out.println("Load Active Unit: "+activeUnit);
		}

		if (game.getDaylightCondition().equals(""))
			comboBoxVisibility.setSelectedIndex(0);

		// Creates hex grid
		// System.out.println("Create hex grid");
		this.hexGrid = new HexGrid(initiativeOrder, gameWindow, hexRows, hexCols);
		if (hexGrid != null && hexGrid.panel.deployedUnits.size() > 0) {
			hexGrid.panel.selectedUnit = hexGrid.panel.deployedUnits.get(activeUnit);
		}

		spinnerHexSize.setValue(hexSize);

		JButton btnNewButton_3 = new JButton("CQB Check");
		btnNewButton_3.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				if (currentlyOpenUnit == null) {
					conflictLog.addNewLine(
							"Use this button at the start of a conflict, specifically when some units are begining the conflict in close quarters battle. "
									+ "Open the first unit in the init order to perform a CQB check.");
					return;
				}

				closeQuartersBattleCheck(currentlyOpenUnit);
			}
		});
		btnNewButton_3.setBounds(444, 101, 128, 23);
		f.getContentPane().add(btnNewButton_3);

	}

	// Opens active unit window
	public void openUnit(Unit unit, int index) {
		// System.out.println("Open unit moral: "+unit.moral);

		try {
			if (currentlyOpenUnit != null)
				currentlyOpenUnit.f.dispose();
			currentlyOpenUnit = new OpenUnit(unit, gameWindow, index);
		} catch (Exception e) {
			System.out.println("toString(): " + e.toString());
			System.out.println("getMessage(): " + e.getMessage());
			System.out.println("StackTrace: ");
			e.printStackTrace();
		}

	}

	// Sets companies equal to the comapny in the setup window
	// Used to save changes made to a company during a conflict
	public void confirmCompany(Company company, int index) {
		setupWindow.setCompany(company, index);
		setupWindow.refreshCreated();
	}

	// Refresh conflict
	public void refreshConflict(SetupWindow setupWindow) {
		this.companies = setupWindow.getActivated();
		rollInitiativeOrder();
		refreshInitiativeOrder();
	}

	public void refreshInitiativeOrder() {
		DefaultListModel initiativeOrderList = new DefaultListModel();

		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Loops through troopers in the unit

			for (int x = 0; x < initiativeOrder.get(i).getSize(); x++) {
				Trooper currentTrooper = initiativeOrder.get(i).getTroopers().get(x);
				currentTrooper.number = x + 1;
			}

			initiativeOrderList.addElement(i + ": " + initiativeOrder.get(i));

		}

		listIniativeOrder.setModel(initiativeOrderList);

		setUnitlabel();
		
		if(hexGrid != null) {
			hexGrid.refreshDeployedUnits();
		}
		
	}

	// Loops through companies
	// Adds units to units array
	// Sets units sides, command value, and initiative
	public void setInitiativeOrder(ArrayList<Company> companies) {
		Random rand = new Random();

		initiativeOrder.clear();

		for (int i = 0; i < companies.size(); i++) {
			Company company = companies.get(i);
			ArrayList<Unit> units = company.getUnits();
			for (int j = 0; j < company.getUnitsLength(); j++) {
				Unit unit = units.get(j);
				// Sets some unit stats
				unit.side = company.getSide();
				unit.company = company.getName();
				unit.getCommandValue();
				int roll = rand.nextInt(10) + 1;
				unit.initiative = roll + unit.commandValue;
				if (unit.active) {
					initiativeOrder.add(unit);
				}

			}
		}

		rollInitiativeOrder();

	}

	// Sets initiative order
	public void rollInitiativeOrder() {

		Unit temp;

		for (int i = 0; i < initiativeOrder.size(); i++) {

			for (int j = 0; j < initiativeOrder.size() - 1; j++) {

				if (initiativeOrder.get(j + 1).initiative > initiativeOrder.get(j).initiative) {
					temp = initiativeOrder.get(j + 1);
					initiativeOrder.set(j + 1, initiativeOrder.get(j));
					initiativeOrder.set(j, temp);

				}
			}
		}

		closeCombatCheck();
		// closeQuartersBattleCheck();
	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void nextActiveUnit() {

		conflictLog.addNewLine("Next unit... Active Unit: " + activeUnit);

		int actions = game.getCurrentAction() + 1;

		// Increases passed active unit members by 1
		if (activeUnit > -1) {
			Unit unit = initiativeOrder.get(activeUnit);
			ArrayList<Trooper> troopers = unit.getTroopers();
			for (int j = 0; j < troopers.size(); j++) {

				// Increases time unconscious
				// Checks for wake up
				if (game.getCurrentAction() <= 3 && game.getCurrentAction() != 0) {

					if (!troopers.get(j).conscious) {

						if (troopers.get(j).timeUnconscious == troopers.get(j).incapacitationTime) {
							troopers.get(j).timeUnconscious = 0;
							troopers.get(j).incapacitationTime = 0;
							conflictLog.addNewLine(troopers.get(j).number + " " + troopers.get(j).name + " from unit:"
									+ unit.callsign + "has awoken.");
							troopers.get(j).conscious = true;
						} else {
							troopers.get(j).timeUnconscious++;
						}

					}

				}

				if (game.getPhase() == 1) {
					if (troopers.get(j).spentPhase1 != actions - 1) {

						if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1)
							troopers.get(j).spentPhase1 += 1;
					}
				} else {
					if (troopers.get(j).spentPhase2 != actions - 1) {

						if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2)
							troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			return;
		}

		int size = initiativeOrder.size();
		size--;

		// If next unit is empty
		// Skips next unit
		// System.out.println("Active Unit: "+activeUnit);
		int unitCount = 1;
		boolean pass = false;
		while (!pass) {

			// Makes sure there is a unit infront of the active unit
			if (activeUnit + unitCount != initiativeOrder.size()) {

				// Checks if the next unit is the last one
				if (activeUnit + 2 == initiativeOrder.size()) {
					// Checks if the last unit is empty
					if (initiativeOrder.get(activeUnit + 1).getSize() < 1) {
						activeUnit = size;
						break;
					}
				}

				// Checks if next unit is empty
				// If unit is alive and not empty
				if (initiativeOrder.get(activeUnit + unitCount).getSize() < 1) {
					// System.out.println("Increase");
					unitCount++;
				} else {

					pass = true;
					activeUnit += unitCount;
					activeUnit--;

				}

				/*
				 * if(activeUnit + unitCount > size || activeUnit > size) { activeUnit = size;
				 * break; }
				 */

				// System.out.println("Modified Active Unit: "+activeUnit);

			} else {
				break;
			}

		}

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		endOfInitOrder(size, actions);

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		openUnit(initiativeOrder.get(activeUnit), activeUnit);

		// Updates Labels
		setUnitlabel();
		setRound();
		setPhase();
		setActions();

	}

	// Performs nessesary checks for twenty seconds of passed time
	public void unitWaitTwentySeconds() {

		int actions = game.getCurrentAction();

		Unit unit = initiativeOrder.get(activeUnit);
		int activeTrooperCount = 0;
		int activeTroopersInCover = 0;
		// Forced Route or Pinned
		for (Trooper trooper : unit.getTroopers()) {

			if (trooper.alive && trooper.conscious) {
				activeTrooperCount++;
				if (trooper.inCover)
					activeTroopersInCover++;
			}

		}

		if (unit.suppression >= 50) {

			if ((double) activeTrooperCount / activeTroopersInCover < 0.5) {
				conflictLog.addNewLine(
						unit.callsign + " is forced to route due to high suppression and minimal cover. This "
								+ "unit can avoid routing if all individuals not in cover can hunker down.");
			} else {
				conflictLog.addNewLine(unit.callsign + " is pinned and cannot move until suppression "
						+ "becomes less than 50. Or a successful command test is made, with one difficulty die for every 10 suppression. "
						+ "And 1 bonus die for each additional leader.");
			}

		}

		// Fire Missions
		for (FireMission fireMission : unit.fireMissions) {
			// System.out.println("Calling Advance Time Fire Mission");
			fireMission.advanceTime();
		}

		ArrayList<Trooper> troopers = unit.getTroopers();
		for (int j = 0; j < troopers.size(); j++) {
			// System.out.println("Pass Trooper: "+j);

			if (!troopers.get(j).alive) {
				troopers.get(j).spentPhase1 = troopers.get(j).P1;
				troopers.get(j).spentPhase2 = troopers.get(j).P2;
				continue;
			}

			// Increases time unconscious
			// Checks for wake up
			if (actions <= 3 && actions != 0) {

				if (!troopers.get(j).conscious) {

					if (troopers.get(j).timeUnconscious >= troopers.get(j).incapacitationTime) {
						troopers.get(j).timeUnconscious = 0;
						troopers.get(j).incapacitationTime = 0;
						conflictLog.addNewLineToQueue(troopers.get(j).number + " " + troopers.get(j).name
								+ " from unit:" + unit.callsign + "has awoken.");
						troopers.get(j).conscious = true;

					} else {
						troopers.get(j).timeUnconscious++;
					}
					troopers.get(j).spentPhase1 = troopers.get(j).P1;
					troopers.get(j).spentPhase2 = troopers.get(j).P2;

					continue;

				}

				Trooper trooper = troopers.get(j);
				if (trooper.personalShield != null) {
					PersonalShield ps = trooper.personalShield;

					if (ps.currentShieldStrength < ps.maxShieldStrength) {

						ps.currentShieldStrength += ps.maxShieldStrength * ps.rechargeRate;

						if (ps.currentShieldStrength > ps.maxShieldStrength)
							ps.currentShieldStrength = ps.maxShieldStrength;

					}

				}

			}

			float time;

			if (gameWindow.game.getPhase() == 1) {
				if (troopers.get(j).P1 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P1;
			} else {
				if (troopers.get(j).P2 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P2;
			}

			if (unit.speed.equals("None")) {
				troopers.get(j).fatigueSystem.AddRecoveryTime(time);
			}

			if (game.getPhase() == 1) {
				if (troopers.get(j).spentPhase1 != actions) {

					if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1) {

						// troopers.get(j).spentPhase1 += 1;
					}
				}
			} else {
				if (troopers.get(j).spentPhase2 != actions) {

					if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2) {

						// troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}
	}

	// Performs nessesary checks for twenty seconds of passed time
	public void unitPassTwentySeconds() {

		int actions = game.getCurrentAction();

		Unit unit = initiativeOrder.get(activeUnit);
		int activeTrooperCount = 0;
		int activeTroopersInCover = 0;
		// Forced Route or Pinned
		for (Trooper trooper : unit.getTroopers()) {

			if (trooper.alive && trooper.conscious) {
				activeTrooperCount++;
				if (trooper.inCover)
					activeTroopersInCover++;
			}

		}

		if (unit.suppression >= 50) {

			if ((double) activeTrooperCount / activeTroopersInCover < 0.5) {
				conflictLog.addNewLine(
						unit.callsign + " is forced to route due to high suppression and minimal cover. This "
								+ "unit can avoid routing if all individuals not in cover can hunker down.");
			} else {
				conflictLog.addNewLine(unit.callsign + " is pinned and cannot move until suppression "
						+ "becomes less than 50. Or a successful command test is made, with one difficulty die for every 10 suppression. "
						+ "And 1 bonus die for each additional leader.");
			}

		}

		// Fire Missions
		for (FireMission fireMission : unit.fireMissions) {
			// System.out.println("Calling Advance Time Fire Mission");
			fireMission.advanceTime();
		}

		ArrayList<Trooper> troopers = unit.getTroopers();
		for (int j = 0; j < troopers.size(); j++) {
			// System.out.println("Pass Trooper: "+j);

			if (!troopers.get(j).alive) {
				troopers.get(j).spentPhase1 = troopers.get(j).P1;
				troopers.get(j).spentPhase2 = troopers.get(j).P2;
				continue;
			}

			// Increases time unconscious
			// Checks for wake up
			if (actions <= 3 && actions != 0) {

				if (!troopers.get(j).conscious) {

					if (troopers.get(j).timeUnconscious >= troopers.get(j).incapacitationTime) {
						troopers.get(j).timeUnconscious = 0;
						troopers.get(j).incapacitationTime = 0;
						conflictLog.addNewLineToQueue(troopers.get(j).number + " " + troopers.get(j).name
								+ " from unit:" + unit.callsign + "has awoken.");
						troopers.get(j).conscious = true;

					} else {
						troopers.get(j).timeUnconscious++;
					}
					troopers.get(j).spentPhase1 = troopers.get(j).P1;
					troopers.get(j).spentPhase2 = troopers.get(j).P2;

					continue;

				}

				Trooper trooper = troopers.get(j);
				if (trooper.personalShield != null) {
					PersonalShield ps = trooper.personalShield;

					if (ps.currentShieldStrength < ps.maxShieldStrength) {

						ps.currentShieldStrength += ps.maxShieldStrength * ps.rechargeRate;

						if (ps.currentShieldStrength > ps.maxShieldStrength)
							ps.currentShieldStrength = ps.maxShieldStrength;

					}

				}

			}

			float time;

			if (gameWindow.game.getPhase() == 1) {
				if (troopers.get(j).P1 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P1;
			} else {
				if (troopers.get(j).P2 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P2;
			}

			// System.out.println("Pass Add Recovery TIme");
			if (unit.speed.equals("None")) {
				troopers.get(j).fatigueSystem.AddRecoveryTime(time);
			}

			if (game.getPhase() == 1) {
				if (troopers.get(j).spentPhase1 != actions) {

					if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1) {

						troopers.get(j).spentPhase1 += 1;
					}
				}
			} else {
				if (troopers.get(j).spentPhase2 != actions) {

					if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2) {

						troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}
	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void safeNextActiveUnit() {
		// System.out.println("\n\nCurrent Action: "+game.getCurrentAction()+" Active
		// Unit: "+activeUnit+"\n\n");

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			// System.out.println("Returning Safe Next Active Unit");
			return;
		}

		unitPassTwentySeconds();

		int size = initiativeOrder.size();
		size--;

		/*
		 * activeUnit++; if(activeUnit == initiativeOrder.size()) activeUnit = 0;
		 */

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		// Might contain gui updates
		// System.out.println("Inside Pass1");
		endOfInitOrder(size, game.getCurrentAction() + 1);

		// System.out.println("Inside Pass2");

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		// listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		// System.out.println("Open Next Active Unit");

	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void safeWaitActiveUnit() {
		// System.out.println("\n\nCurrent Action: "+game.getCurrentAction()+" Active
		// Unit: "+activeUnit+"\n\n");

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			// System.out.println("Returning Safe Next Active Unit");
			return;
		}

		unitWaitTwentySeconds();

		int size = initiativeOrder.size();
		size--;

		/*
		 * activeUnit++; if(activeUnit == initiativeOrder.size()) activeUnit = 0;
		 */

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		// Might contain gui updates
		// System.out.println("Inside Pass1");
		endOfInitOrder(size, game.getCurrentAction() + 1);
		// System.out.println("Inside Pass2");

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		// listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		// System.out.println("Open Next Active Unit");

	}

	public void guiUpdateNextActiveUnit() {

		conflictLog.addNewLine("Next unit... Active Unit: " + activeUnit);

		// Updates Labels
		setUnitlabel();
		setRound();
		setPhase();
		setActions();

	}

	// Takes a trooper, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public static boolean exhaustedTrooper(Trooper trooper) {
		//System.out.println("Exuasted Trooper test: "+trooper.name);
		if (GameWindow.gameWindow.game.getPhase() == 1) {
			if (trooper.spentPhase1 < trooper.P1) {
				//System.out.println("Return False");
				return false;
			}
		} else {
			if (trooper.spentPhase2 < trooper.P2) {
				//System.out.println("Return False");
				return false;
			}
		}
		
		//System.out.println("Return True");
		return true;
	}

	// Takes a unit, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public static boolean exhaustedUnit(Unit unit) {

		// System.out.println("Entering Exhusted Unit Check");

		
		
		for (Trooper trooper : unit.getTroopers()) {
			if(!exhaustedTrooper(trooper))
				return false; 
		}

		// System.out.println("Returning True");
		return true;
	}
	
	public static boolean mostlyExhausted(Unit unit) {
		
		int exausted = 0, fresh = 0;
		
		for (Trooper trooper : unit.getTroopers()) {
			if(exhaustedTrooper(trooper))
				exausted++;
			else 
				fresh++; 
		}

		if(exausted >= fresh) {
			return true;
		} else {
			return false; 
		}
	}

	public static boolean anyoneExhausted(Unit unit) {
		for (Trooper trooper : unit.getTroopers()) {
			if(exhaustedTrooper(trooper))
				return true; 
		}

		// System.out.println("Returning True");
		return false;
	}
	
	// Returns true if all individuals have spent ap for this action, returns false
	// if they have not
	public boolean checkForAllExahusted() {

		for (Unit unit : initiativeOrder) {
			if (!exhaustedUnit(unit))
				return false;
		}

		return true;
	}

	// Takes a unit, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public boolean endActionUnit(Unit unit) {

		// System.out.println("Entering End Action Unit Check");

		for (Trooper trooper : unit.getTroopers()) {
			if (game.getPhase() == 1) {
				if (trooper.spentPhase1 < trooper.P1
						&& trooper.spentPhase1 < GameWindow.gameWindow.game.getCurrentAction()) {
					// System.out.println("Returning False");
					return false;
				}
			} else {
				if (trooper.spentPhase2 < trooper.P2
						&& trooper.spentPhase2 < GameWindow.gameWindow.game.getCurrentAction()) {
					// System.out.println("Returning False");
					return false;
				}
			}
		}

		// System.out.println("Returning True");
		return true;
	}

	// Returns true if all individuals have spent ap for this action, returns false
	// if they have not
	public boolean checkForAllEndAction() {

		for (Unit unit : initiativeOrder) {
			if (!endActionUnit(unit))
				return false;
		}

		return true;
	}

	// Checks and performs tasks for the end of the init order
	public void endOfInitOrder(int size, int actions) {

		boolean endOfPhase = checkForAllExahusted();
		boolean endOfAction = checkForAllEndAction();

		if (endOfPhase) {
			conflictLog.addNewLineToQueue("End of Phase");
			// game.setCurrentAction(actions);
			// conflictLog.addNewLineToQueue("Actions: " + actions);
			// Checks for end of phase
			// Loops through units indiviudals

			// Checks for artillery fire missions
			int diff = 3 - game.getCurrentAction();
			//System.out.println("diff: "+diff);
			for(Unit unit : initiativeOrder) {
				// Fire Missions
				for (FireMission fireMission : unit.fireMissions) {
					// System.out.println("Calling Advance Time Fire Mission");
					for(int i = 0; i < diff; i++) {
						fireMission.advanceTime();						
					}
					
				}
			}
			
			// Check for end of round or phase
			if (game.getPhase() == 1) {
				game.setPhase(2);
				// End of phase
				conflictLog.addNewLineToQueue("     Round: " + game.getRound() + " Phase: 2");
				endOfPhase();
			} else {
				game.setPhase(1);
				int round = game.getRound() + 1;
				game.setRound(round);
				conflictLog.addNewLineToQueue("     Round: " + game.getRound() + " Phase: 1");
				// End of round
				endOfPhase();
				endOfRound();

			}

			activeUnit = 0;
		} else if (endOfAction) {
			game.setCurrentAction(actions);
			conflictLog.addNewLineToQueue("End of Action");
			conflictLog.addNewLineToQueue("Actions: " + actions);
			activeUnit = 0;
			
			//System.out.println("End of action");
			
			// Action ended 
			for(DeployedUnit deployedUnit : hexGrid.panel.deployedUnits) {
				deployedUnit.moved = false; 
			}
			
			int currentAction = game.getCurrentAction();
			// Performs spot test
			if (currentAction == 1 || currentAction == 2 || currentAction == 3)
				spotCycle();

		} else if (activeUnit >= size) {

			for (int i = 0; i < initiativeOrder.size(); i++) {

				if (!endActionUnit(initiativeOrder.get(i))) {
					activeUnit = i;
					break;
				}

			}
			
			
			

		} else {
			activeUnit++;
		}
		

	}

	public void closeQuartersBattleCheck(OpenUnit openUnit) {

		cqb.closeQuartersBattleCheck(openUnit);

	}

	// Sets active unit label
	public void setUnitlabel() {
		if (initiativeOrder == null || initiativeOrder.size() < 1)
			return;
		else if (activeUnit > initiativeOrder.size())
			return;
		else if (activeUnit >= initiativeOrder.size()) {
			activeUnit = 0;
			return;
		} else if (initiativeOrder.get(activeUnit) == null)
			return;

		lblActiveUnit.setText("Active Unit: " + initiativeOrder.get(activeUnit).side + "::  "
				+ initiativeOrder.get(activeUnit).callsign);
	}

	// Set round
	public void setRound() {
		lblRound.setText("Round: " + game.getRound());
	}

	// Set phase
	public void setPhase() {
		lblPhase.setText("Phase: " + game.getPhase());

	}

	// Set actions
	public void setActions() {
		lblActions.setText("Actions: " + game.getCurrentAction());
	}

	// End of round
	// Loops through initiative order
	// Resets each troopers spentPhase AP to 0
	// Checks if a trooper is unconscious
	// If the trooper is unconscious increases the time unconscious by two minutes
	// Performs wake up tests is applicable
	public void endOfRound() {
		game.setCurrentAction(1);
		Random rand = new Random();

		// Loops through initiative order order
		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Gets current unit
			Unit unit = initiativeOrder.get(i);

			if (unit.behavior.equals("Recent Contact")) {
				unit.timeSinceContact += 1;

			}

			/*
			 * if(unit.timeSinceContact >= 5) { unit.behavior = "No Contact";
			 * unit.timeSinceContact = 0; }
			 */

			// Gets troopers
			ArrayList<Trooper> troopers = unit.getTroopers();

			// Loops through troopers
			for (int j = 0; j < unit.getSize(); j++) {
				Trooper trooper = troopers.get(j);
				// int TN = trooper.endurance;
				// Resets spent ap
				trooper.spentPhase1 = 0;
				trooper.spentPhase2 = 0;

				// Checks if trooper is conscious
				if (!trooper.conscious) {
					/*
					 * // Increases time spent unconscious trooper.timeUnconscious += 2;
					 * 
					 * // Performs wake up tests
					 * 
					 * 
					 * 
					 * if(trooper.timeUnconscious >= 14 && trooper.currentHP > 0) {
					 * trooper.conscious = true;
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has woken up..."); trooper.timeUnconscious = 0; }
					 * 
					 * 
					 * 
					 * int roll = rand.nextInt(100) + 1;
					 * 
					 * if(trooper.currentHP < -1 * trooper.hp) { if(trooper.timeUnconscious >= 718)
					 * { if(roll > TN) {
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has died of their injuries..."); trooper.alive = false; } } } else
					 * if(trooper.currentHP < 1) { if(trooper.timeUnconscious >= 58) { if(roll <=
					 * TN) {
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has woken up..."); trooper.conscious = true; trooper.timeUnconscious
					 * = 0; } } }
					 */

				}

				// Checks if trooper is mortally wounded
				/*
				 * if(trooper.mortallyWounded) { // Increases time spent mortally wounded
				 * trooper.timeMortallyWounded += 2;
				 * 
				 * // Checks if mortal wound is stabalized, makes rolls once per hour // If the
				 * character is not stablaized then rolls occur every half hour
				 * if(trooper.timeMortallyWounded >= 58 && trooper.stabalized) { int tempTN;
				 * 
				 * int skill = trooper.physicianSkill;
				 * 
				 * if(skill > TN) { tempTN = skill; } else { tempTN = TN; }
				 * 
				 * int roll = rand.nextInt(100) + 1; if(roll > tempTN) { trooper.alive = false;
				 * conflictLog.addNewLineToQueue(unit.callsign+":: "+trooper.name+", Number: "
				 * +trooper.number+" has died of their injuries..."); }
				 * 
				 * } else if(trooper.timeMortallyWounded >= 28) { int roll = rand.nextInt(100) +
				 * 1; if(roll > TN) { trooper.alive = false;
				 * conflictLog.addNewLineToQueue(unit.callsign+":: "+trooper.name+", Number: "
				 * +trooper.number+" has died of their injuries..."); } }
				 * 
				 * }
				 */

			}
		}
	}

	// End of phase

	public void endOfPhase() {

		// Loops through all individuals, increases time passed for wounds
		// Checks unit morale, forces individuals to hunker down that are subject to the
		// morale failure

		for (int i = 0; i < initiativeOrder.size(); i++) {

			for (int x = 0; x < initiativeOrder.get(i).getSize(); x++) {

				if (initiativeOrder.get(i).moral < 30) {
					Random rand = new Random();
					int roll = rand.nextInt(10) + 1;

					if (roll < initiativeOrder.get(i).getTroopers().get(x).P1
							+ initiativeOrder.get(i).getTroopers().get(x).P2) {

						if (initiativeOrder.get(i).getTroopers().get(x).inCover) {
							initiativeOrder.get(i).getTroopers().get(x).HD = true;
							conflictLog.addNewLineToQueue(initiativeOrder.get(i).getTroopers().get(x).number + " "
									+ initiativeOrder.get(i).getTroopers().get(x).name
									+ " hunkers down. Morale too low.");
						}

					}

				}

				initiativeOrder.get(i).getTroopers().get(x).advanceTime(this, conflictLog);
			}

		}

		for (int i = 0; i < initiativeOrder.size(); i++) {
			if (initiativeOrder.get(i).suppression - 10 > 0) {
				initiativeOrder.get(i).suppression -= 5;
			} else {
				initiativeOrder.get(i).suppression = 0;
			}

			if (initiativeOrder.get(i).behavior.equals("No Contact")) {
				initiativeOrder.get(i).organization += initiativeOrder.get(i).commandValue
						+ (initiativeOrder.get(i).moral / 20);
			} else if (initiativeOrder.get(i).behavior.equals("Recent Contact")) {
				initiativeOrder.get(i).organization += initiativeOrder.get(i).commandValue
						+ (initiativeOrder.get(i).moral / 20) / 2;
			}

			if (initiativeOrder.get(i).organization > 100) {

				initiativeOrder.get(i).organization = 100;

			}
		}

		// Loops through initiative order order
		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Gets current unit
			Unit unit = initiativeOrder.get(i);
			// Gets troopers
			ArrayList<Trooper> troopers = unit.getTroopers();

			// Loops through troopers
			for (int j = 0; j < unit.getSize(); j++) {
				Trooper trooper = troopers.get(j);

				// Checks for shields
				// Recharges sheilds
				if (trooper.shields > 0) {
					trooper.currentShields = trooper.shields;
				}

			}

		}

		game.setCurrentAction(1);

	}

	// Loops through each unit
	// Rolls spot for all individuals against units that are not on their side
	public void spotCycle() {

		for (Iterator<Unit> iteratorInitOrder = initiativeOrder.iterator(); iteratorInitOrder.hasNext();) {

			Unit spotterUnit = iteratorInitOrder.next();
			// System.out.println("Spotter Unit: "+spotterUnit);

			for (Iterator<Trooper> troopers = spotterUnit.individuals.iterator(); troopers.hasNext();) {
				Trooper spotterTrooper = troopers.next();
				// System.out.println("Spotter Trooper: "+spotterTrooper.name);
				for (Iterator<Unit> targetUnits = spotterUnit.lineOfSight.iterator(); targetUnits.hasNext();) {

					Unit targetUnit = targetUnits.next();
					// System.out.println("Target Unit: "+targetUnit.callsign);
					// System.out.println("Entering Spot 1");
					spot(targetUnit, spotterUnit, spotterTrooper);
					// System.out.println("Exiting Spot 2");
				}

			}

		}

		/*
		 * for (int i = 0; i < initiativeOrder.size(); i++) { // Gets spotter unit Unit
		 * spotterUnit = initiativeOrder.get(i);
		 * 
		 * // Loops through troopers for(int x = 0; x <
		 * spotterUnit.getTroopers().size(); x++) {
		 * 
		 * // Clears trooper's spot spotterUnit.getTroopers().get(x).spotted.clear();
		 * 
		 * // Loops through units a second time for (int j = 0; j <
		 * initiativeOrder.size(); j++) {
		 * 
		 * // If not the same unit if(!initiativeOrder.get(j).compareTo(spotterUnit) &&
		 * !initiativeOrder.get(j).side.equals(spotterUnit.side)) {
		 * 
		 * 
		 * // Performs spot test spot(initiativeOrder.get(j), spotterUnit,
		 * spotterUnit.getTroopers().get(x));
		 * 
		 * 
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 */

	}

	// Creates new spot action and adds it to trooper
	public void spot(Unit targetUnit, Unit spotterUnit, Trooper trooper) {
		// System.out.println("Target Unit: "+targetUnit.callsign);
		// System.out.println("spotterUnit: "+spotterUnit.callsign);

		for (Unit unit : spotterUnit.lineOfSight) {
			// System.out.println("Unit in LOS: "+unit.callsign);
		}

		// System.out.println("spotterUnitLOS: "+spotterUnit.lineOfSight);
		if (!spotterUnit.lineOfSight.contains(targetUnit)) {
			// System.out.println("No LOS to Units: Spotter Unit: "+spotterUnit.callsign+",
			// targetUnit: "+targetUnit.callsign);
			return;
		}

		// System.out.println("New Spot Action 1");
		Spot spotAction = new Spot(gameWindow, spotterUnit, targetUnit, trooper, "180 Degrees", gameWindow.visibility,
				gameWindow.initiativeOrder, gameWindow);
		// System.out.println("New Spot Action 2");
		// Set results in trooper
		trooper.spotted.add(spotAction);
		// System.out.println("New Spot Action 3");
	}

	// Takes units from companies not already in the init order
	// Makes an init roll
	public void refreshUnits() {

		Random rand = new Random();

		ArrayList<Company> companies = setupWindow.getActivated();

		for (int i = 0; i < companies.size(); i++) {
			Company company = companies.get(i);
			ArrayList<Unit> units = company.getUnits();
			for (int j = 0; j < company.getUnitsLength(); j++) {
				Unit unit = units.get(j);

				boolean alreadyExists = false;
				for (Unit initUnit : initiativeOrder) {
					if (unit.callsign.equals(initUnit.callsign))
						alreadyExists = true;
				}

				if (!alreadyExists) {
					// Sets some unit stats
					unit.side = company.getSide();
					unit.company = company.getName();
					unit.getCommandValue();

					if (game.getPhase() == 1) {
						for (Trooper trooper : unit.getTroopers()) {

							trooper.spentPhase1 = game.getCurrentAction() - 1;

							if (game.getCurrentAction() == 1)
								trooper.spentPhase1 = 0;

						}
					} else {
						for (Trooper trooper : unit.getTroopers()) {

							trooper.spentPhase1 = trooper.P1;
							trooper.spentPhase2 = game.getCurrentAction() - 1;

							if (game.getCurrentAction() == 1)
								trooper.spentPhase2 = 0;

						}
					}

					int roll = rand.nextInt(10) + 1;

					unit.initiative = roll + unit.commandValue;
					if (unit.active) {
						initiativeOrder.add(unit);
					}
				}

			}
		}

		// Removes deactivated units
		/*
		 * for(Unit unit : initiativeOrder) {
		 * 
		 * if(!unit.active) {
		 * 
		 * initiativeOrder.remove(unit);
		 * 
		 * }
		 * 
		 * }
		 */

		// rollInitiativeOrder();
		refreshInitiativeOrder();

	}

	// Loops through all units in the iniiative order, checks if close combat should
	// be initaited
	public void closeCombatCheck() {

		int size = initiativeOrder.size();

		for (int i = 0; i < size; i++) {

			Unit unit = initiativeOrder.get(i);
			boolean closeCombat = false;

			ArrayList<Trooper> flee = new ArrayList<>();
			boolean rout = false;

			for (int x = 0; x < size; x++) {

				Unit unit2 = initiativeOrder.get(x);

				if (!unit.compareTo(unit2)) {

					if (unit.X == unit2.X && unit.Y == unit2.Y && !unit.side.equals(unit2.side)) {
						closeCombat = true;
						Random rand = new Random();

						if (!unit.closeCombat) {
							unit.closeCombat = true;

							if (unit.individuals.size() > 0) {

								int leaderShipRoll = rand.nextInt(100) + 1;

								// System.out.println("LR Roll 1: "+leaderShipRoll);

								if (unit.moral < 60) {
									int margin = 60 - unit.moral;
									margin = margin / 10;
									leaderShipRoll += margin * 10;

								}

								// System.out.println("LR Roll Modded: "+leaderShipRoll);

								gameWindow.conflictLog.addNewLine("Entering Close Combat: " + unit.callsign);
								gameWindow.conflictLog.addNewLine("Command: " + unit.individuals.get(0).command);
								gameWindow.conflictLog.addNewLine("Leadership Roll: " + leaderShipRoll);
								gameWindow.conflictLog.addNewLine("Unit Morale: " + unit.moral);

								if (leaderShipRoll > unit.individuals.get(0).command) {
									for (int j = 0; j < unit.individuals.size(); j++) {
										int roll = rand.nextInt(100) + 1;
										gameWindow.conflictLog.addNewLine(unit.individuals.get(j).name + " "
												+ unit.individuals.get(j).number + " Morale Roll: " + roll);

										if (roll > unit.moral) {
											flee.add(unit.individuals.get(j));
											rout = true;

										}
									}
								}
							}

						}

					}

				}

			}
			if (!closeCombat) {
				unit.closeCombat = false;
			}

			if (rout) {
				unit.flee(gameWindow, unit, flee);
			}

		}

	}

	// Targets X and Y, returns hex
	public Hex findHex(int x, int y) {

		for (Hex hex : hexes) {
			if (hex.xCord == x && hex.yCord == y)
				return hex;
		}

		return null;

	}

	// Finds the differance between the two locations
	public static int hexDif(Unit targetUnit, Unit shooterUnit) {
		return hexDif(targetUnit.X, targetUnit.Y, shooterUnit.X, shooterUnit.Y);
	}

	// Finds the differance between the two locations
	public static int hexDif(int x, int y, Unit shooterUnit) {
		return hexDif(x, y, shooterUnit.X, shooterUnit.Y);
	}

	public static int hexDif(int x, int y, int x1, int y1) {
		return dist(x, y, x1, y1);
	}
	
	public static int dist(int x1, int x2, int y1, int y2) {
		
		int du = x2 - x1;
		int dv = Math.floorDiv(y2 + x2)(y2 + x2 / 2)
		
		
	}
	
	
	public ArrayList<Unit> getUnitsInHex(String sideSpecified, int x, int y) {

		ArrayList<Unit> units = new ArrayList<>();

		for (Unit unit : initiativeOrder) {
			if (unit.X != x || unit.Y != y)
				continue;

			if (unit.side.equals(sideSpecified) || (sideSpecified.equals("") || sideSpecified.equals("None"))) {
				units.add(unit);
			}
		}

		return units;
	}

	public ArrayList<Unit> getUnitsInHexExcludingSide(String sideSpecified, int x, int y) {

		ArrayList<Unit> units = new ArrayList<>();

		for (Unit unit : initiativeOrder) {
			if (unit.X != x || unit.Y != y)
				continue;

			// System.out.println("Add unit");
			if (!unit.side.equals(sideSpecified) || (sideSpecified.equals("") || sideSpecified.equals("None"))) {
				units.add(unit);
			}
		}

		return units;
	}

	public static String getLogHead(Trooper target) {
		return GameWindow.findTrooperUnit(target).callsign + ", " + target.number + ": " + target.name;
	}

	public static void addTrooperEntryToLog(Trooper trooper, String text) {
		GameWindow.gameWindow.conflictLog.addNewLineToQueue(GameWindow.gameWindow.getLogHead(trooper) + " " + text);
	}

	// Loops through units in initiaitive order
	// Looks for unit containing indvididual
	// Returns unit
	public static Unit findTrooperUnit(Trooper trooper) {
		ArrayList<Unit> units = gameWindow.initiativeOrder;

		for (Unit unit : units) {

			for (Trooper trooper1 : unit.getTroopers()) {

				if (trooper1.compareTo(trooper))
					return unit;

			}

		}

		return null;

	}

	public void randomEventCheck() {
		Random rand = new Random();

		if (rand.nextInt(100) + 1 < 5) {
			conflictLog.addNewLine("Random Event Has Occured");
		}

	}

	public void refreshCompanyUnits() {
		// Auto-generated method stub
		conflictLog.addNewLine("Refreshed Units");

		for (Unit unit : initiativeOrder) {

			for (Company company : setupWindow.companies) {

				if (company.getName().equals(unit.company)) {

					for (Unit secondUnit : company.getUnits()) {

						if (secondUnit.callsign.equals(unit.callsign))
							company.getUnits().set(company.getUnits().indexOf(secondUnit), unit);

					}

				}

			}

		}

		setupWindow.refreshCreated();
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-01 11:46:34.279
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-01 11:46:34.279
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-01 11:46:34.308
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package Conflict;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.Random;

import javax.swing.DefaultListModel;
import javax.swing.JFrame;
import javax.swing.JScrollPane;

import Company.Company;
import CreateGame.SetupWindow;
import HexGrid.HexGrid;
import HexGrid.HexGrid.DeployedUnit;
import Hexes.Hex;
import Hexes.HexWindow;
import Items.PersonalShield;
import Trooper.Trooper;
import Unit.Unit;
import UtilityClasses.HexGridUtility;

import javax.swing.JList;
import javax.swing.JButton;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import java.lang.reflect.Array;

import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.JLabel;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.Toolkit;

import javax.swing.LayoutStyle.ComponentPlacement;

import Actions.Spot;
import Artillery.FireMission;

import javax.swing.JComboBox;
import javax.swing.DefaultComboBoxModel;
import java.awt.event.ItemListener;
import java.awt.event.ItemEvent;
import javax.swing.JSpinner;
import javax.swing.SwingWorker;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

public class GameWindow implements Serializable {
	public static int hexSize = 20;
	public ArrayList<Company> companies;
	public ArrayList<Unit> initiativeOrder = new ArrayList<Unit>();
	public Game game;
	public String visibility = "Good Visibility";
	public ArrayList<Hex> hexes = new ArrayList<Hex>();
	public CloseQuartersBattle cqb = new CloseQuartersBattle(this);
	public ConflictLog conflictLog;
	public static GameWindow gameWindow;

	public SetupWindow setupWindow;
	public JList listIniativeOrder;
	public JFrame f = null;
	public int activeUnit = 0;
	private JLabel lblActiveUnit;
	private JLabel lblRound;
	private JLabel lblPhase;
	private JLabel lblActions;
	public JComboBox comboBoxVisibility;
	private JButton btnStartingSpotTest;
	private JSpinner spinnerInitMod;
	private JComboBox comboBoxInitModSide;
	private JComboBox comboBoxValueMod;
	private JSpinner spinnerValueMod;
	private JSpinner spinnerActiveUnit;
	public HexGrid hexGrid;
	public boolean cqbWindowOpen = false;
	public OpenUnit currentlyOpenUnit;
	private JSpinner spinnerHexSize;
	public int hexCols; 
	public int hexRows; 
	

	/**
	 * Launch the application.
	 */
	public GameWindow(ArrayList<Company> companiesFromSetupWindow, SetupWindow setupWindow, Game game,
			boolean openUnit, int hexRows, int hexCols) {
		this.hexCols = hexCols;
		this.hexRows = hexRows; 
		this.game = game;
		this.gameWindow = this;
		this.conflictLog = new ConflictLog();
		this.setupWindow = setupWindow;
		this.companies = companiesFromSetupWindow;
		conflictLog.addNewLine("     Round: " + game.getRound() + " Phase: " + game.getPhase());
		f = new JFrame("Conflict");
		f.setSize(600, 545);

		// Get the screen size
		Toolkit toolkit = Toolkit.getDefaultToolkit();
		Dimension screenSize = toolkit.getScreenSize();
		// Calculate the frame location
		int x = (screenSize.width - f.getWidth()) / 2;
		int y = (screenSize.height - f.getHeight()) / 2;

		// Set the new frame location
		f.setLocation(x, y);

		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent ev) {
				// frame.dispose();
			}
		});

		JScrollPane scrollPane = new JScrollPane();
		scrollPane.setBounds(10, 196, 564, 302);

		listIniativeOrder = new JList();
		listIniativeOrder.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				Unit unit = initiativeOrder.get(listIniativeOrder.getSelectedIndex());
				// System.out.println("Open unit moral: "+unit.moral);

				if (currentlyOpenUnit != null)
					currentlyOpenUnit.f.dispose();
				currentlyOpenUnit = new OpenUnit(unit, gameWindow, listIniativeOrder.getSelectedIndex());
			}
		});
		scrollPane.setViewportView(listIniativeOrder);

		JButton btnRefreshUnits = new JButton("Add New Units");
		btnRefreshUnits.setBounds(10, 39, 128, 25);
		btnRefreshUnits.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				refreshUnits();

			}
		});

		lblActiveUnit = new JLabel("Active Unit: ");
		lblActiveUnit.setBounds(328, 11, 233, 17);
		lblActiveUnit.setFont(new Font("Calibri", Font.BOLD, 13));

		lblRound = new JLabel("Round:");
		lblRound.setBounds(10, 11, 113, 17);
		lblRound.setFont(new Font("Calibri", Font.BOLD, 13));

		lblPhase = new JLabel("Phase:");
		lblPhase.setBounds(129, 11, 113, 17);
		lblPhase.setFont(new Font("Calibri", Font.BOLD, 13));

		lblActions = new JLabel("Actions:");
		lblActions.setBounds(248, 11, 113, 17);
		lblActions.setFont(new Font("Calibri", Font.BOLD, 13));

		JButton btnD = new JButton("D100");
		btnD.setBounds(148, 40, 69, 23);
		btnD.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {
				Random rand = new Random();
				int roll = rand.nextInt(100) + 1;
				conflictLog.addNewLine("Roll: " + roll);
			}
		});

		comboBoxVisibility = new JComboBox();
		comboBoxVisibility.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {

				visibility = comboBoxVisibility.getSelectedItem().toString();
				game.setDaylightCondition(visibility);

			}
		});
		comboBoxVisibility.setBounds(219, 162, 193, 23);
		comboBoxVisibility.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent arg0) {

			}
		});
		comboBoxVisibility.setModel(new DefaultComboBoxModel(
				new String[] { "Good Visibility", "Dusk", "Night - Full Moon ", "Night - Half Moon", "Night - No Moon",
						"Smoke/Fog/Haze/Overcast", "Dusk - Smoke/Fog/Haze/Overcast", "Night - Smoke/Fog/Haze/Overcast",
						"No Visibility - Heavy Fog - White Out" }));

		JLabel lblVisibility = new JLabel("Visibility:");
		lblVisibility.setBounds(152, 165, 59, 17);
		lblVisibility.setFont(new Font("Calibri", Font.BOLD, 13));

		btnStartingSpotTest = new JButton("General Spot Test");
		btnStartingSpotTest.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
			}
		});
		btnStartingSpotTest.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {

						// System.out.println("Spot1");
						spotCycle();
						// System.out.println("Spot2");
						return null;
					}

					@Override
					protected void done() {

						// System.out.println("Done");
						gameWindow.conflictLog.addQueuedText();
						gameWindow.conflictLog.addNewLine("General Spot Test Completed");
					}

				};

				worker.execute();

			}
		});
		btnStartingSpotTest.setBounds(444, 162, 128, 23);
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

		setInitiativeOrder(companies);
		refreshInitiativeOrder();

		// Sets next active unit
		listIniativeOrder.setSelectedIndex(activeUnit);
		f.getContentPane().setLayout(null);
		f.getContentPane().add(btnStartingSpotTest);
		f.getContentPane().add(scrollPane);
		f.getContentPane().add(lblVisibility);
		f.getContentPane().add(comboBoxVisibility);
		f.getContentPane().add(btnRefreshUnits);
		f.getContentPane().add(lblRound);
		f.getContentPane().add(lblPhase);
		f.getContentPane().add(lblActions);
		f.getContentPane().add(lblActiveUnit);
		f.getContentPane().add(btnD);

		JButton btnNewButton = new JButton("Roll Init Order");
		btnNewButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				setInitiativeOrder(companies);

				for (Unit unit : initiativeOrder) {
					if (unit.side.equals(comboBoxInitModSide.getSelectedItem()))
						unit.initiative += (int) spinnerInitMod.getValue();
				}

				rollInitiativeOrder();
				refreshInitiativeOrder();
			}
		});
		btnNewButton.setBounds(256, 70, 128, 23);
		f.getContentPane().add(btnNewButton);

		JLabel lblInitMod = new JLabel("Init Mod:");
		lblInitMod.setFont(new Font("Calibri", Font.BOLD, 13));
		lblInitMod.setBounds(133, 73, 59, 17);
		f.getContentPane().add(lblInitMod);

		spinnerInitMod = new JSpinner();
		spinnerInitMod.setBounds(202, 71, 44, 20);
		f.getContentPane().add(spinnerInitMod);

		comboBoxInitModSide = new JComboBox();
		comboBoxInitModSide.setModel(new DefaultComboBoxModel(new String[] { "BLUFOR", "OPFOR", "IND" }));
		comboBoxInitModSide.setSelectedIndex(0);
		comboBoxInitModSide.setBounds(48, 68, 75, 23);
		f.getContentPane().add(comboBoxInitModSide);

		JLabel lblSide = new JLabel("Side:");
		lblSide.setFont(new Font("Calibri", Font.BOLD, 13));
		lblSide.setBounds(10, 72, 59, 17);
		f.getContentPane().add(lblSide);

		JLabel lblValueMod = new JLabel("Stat Mod:");
		lblValueMod.setFont(new Font("Calibri", Font.BOLD, 13));
		lblValueMod.setBounds(10, 104, 59, 17);
		f.getContentPane().add(lblValueMod);

		JButton btnNewButton_1 = new JButton("Org.");
		btnNewButton_1.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.organization + (int) spinnerValueMod.getValue() > 100) {
							unit.organization = 100;
						} else {
							unit.organization += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnNewButton_1.setBounds(369, 101, 59, 23);
		f.getContentPane().add(btnNewButton_1);

		JLabel label = new JLabel("Side:");
		label.setFont(new Font("Calibri", Font.BOLD, 13));
		label.setBounds(123, 104, 59, 17);
		f.getContentPane().add(label);

		comboBoxValueMod = new JComboBox();
		comboBoxValueMod.setModel(new DefaultComboBoxModel(new String[] { "BLUFOR", "OPFOR", "IND" }));
		comboBoxValueMod.setBounds(152, 101, 89, 23);
		f.getContentPane().add(comboBoxValueMod);

		JButton btnMorale = new JButton("Mor.");
		btnMorale.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.moral + (int) spinnerValueMod.getValue() > 100) {
							unit.moral = 100;
						} else {
							unit.moral += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnMorale.setBounds(309, 101, 59, 23);
		f.getContentPane().add(btnMorale);

		JButton btnSup = new JButton("Sup.");
		btnSup.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				for (Unit unit : initiativeOrder) {

					if (unit.side.equals(comboBoxValueMod.getSelectedItem())) {

						if (unit.suppression + (int) spinnerValueMod.getValue() > 100) {
							unit.suppression = 100;
						} else {
							unit.suppression += (int) spinnerValueMod.getValue();
						}

					}

				}

				refreshInitiativeOrder();

			}
		});
		btnSup.setBounds(248, 101, 59, 23);
		f.getContentPane().add(btnSup);

		spinnerValueMod = new JSpinner();
		spinnerValueMod.setBounds(69, 102, 44, 20);
		f.getContentPane().add(spinnerValueMod);

		JButton btnNewButton_2 = new JButton("Hexes");
		btnNewButton_2.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {

				new HexWindow(gameWindow);

			}
		});
		btnNewButton_2.setBounds(10, 162, 128, 23);
		f.getContentPane().add(btnNewButton_2);

		JButton btnSet = new JButton("Set");
		btnSet.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
			}
		});
		btnSet.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				activeUnit = (int) spinnerActiveUnit.getValue();
				setUnitlabel();
			}
		});
		btnSet.setBounds(153, 132, 89, 23);
		f.getContentPane().add(btnSet);

		spinnerActiveUnit = new JSpinner();
		spinnerActiveUnit.setBounds(94, 133, 44, 20);
		f.getContentPane().add(spinnerActiveUnit);

		JLabel lblActiveUnit_1 = new JLabel("Active Unit:");
		lblActiveUnit_1.setFont(new Font("Calibri", Font.BOLD, 13));
		lblActiveUnit_1.setBounds(10, 134, 80, 17);
		f.getContentPane().add(lblActiveUnit_1);

		JButton btnClearAllSpotted = new JButton("Clear All Spotted");
		btnClearAllSpotted.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				
				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {

						// System.out.println("Clear Spot1");

						for (Unit unit : initiativeOrder) {

							for (Trooper trooper : unit.individuals) {

								trooper.spotted.clear();

							}

						}

						conflictLog.addNewLine("Cleared spotted.");
						
						// System.out.println("Clear Spot2");
						return null;
					}

				};

				worker.execute();
				
			}
		});
		btnClearAllSpotted.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent arg0) {

				

			}
		});
		btnClearAllSpotted.setBounds(444, 132, 128, 23);
		f.getContentPane().add(btnClearAllSpotted);

		JButton btnRefreshCompanyUnits = new JButton("Refresh Company Units");
		btnRefreshCompanyUnits.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				refreshCompanyUnits();

			}

		});
		btnRefreshCompanyUnits.setBounds(231, 39, 165, 25);
		f.getContentPane().add(btnRefreshCompanyUnits);

		JButton btnSkipTo = new JButton("Skip To");
		btnSkipTo.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {

					@Override
					protected Void doInBackground() throws Exception {
						int originalAU = activeUnit;
						int newActiveUnit = (int) spinnerActiveUnit.getValue();
						
						//System.out.println("Original AU: "+originalAU);
						//System.out.println("Next Active Unit: "+newActiveUnit);
						
						if (newActiveUnit <= originalAU) {

							// Skips to end of init order
							for (int i = originalAU; i < initiativeOrder.size(); i++) {

								try {

									if(newActiveUnit == 0 
											&& newActiveUnit != originalAU 
											&& i == initiativeOrder.size() - 1)
										return null;
									
									safeNextActiveUnit();

								} catch (Exception e2) {
									e2.printStackTrace();
								}

							}
							
							
							
							// skips to active unit
							for (int i = 0; i < newActiveUnit; i++) {

								try {

									safeNextActiveUnit();

								} catch (Exception e2) {
									e2.printStackTrace();
								}

							}

						} else {
							for (int i = originalAU; i < newActiveUnit; i++) {

								/*
								 * for(Trooper trooper : initiativeOrder.get(i).individuals) {
								 * if(game.getPhase() == 1) { trooper.spentPhase1 = game.getCurrentAction(); }
								 * else { trooper.spentPhase2 = game.getCurrentAction(); } }
								 */

								try {

									safeNextActiveUnit();

								} catch (Exception e2) {
									System.out.println("toString(): " + e2.toString());
									System.out.println("getMessage(): " + e2.getMessage());
									System.out.println("StackTrace: ");
									e2.printStackTrace();
								}

							}
						}
						
						return null;
					}

					@Override
					protected void done() {
						conflictLog.addQueuedText();
						guiUpdateNextActiveUnit();

						if(hexGrid != null) {
							hexGrid.panel.shownType = HexGridUtility.getShownTypeFromSide(initiativeOrder.get(activeUnit).side);
						}
						
						openUnit(initiativeOrder.get(activeUnit), activeUnit);
						hexGrid.frame.toFront();
						hexGrid.frame.requestFocus();
					}

				};

				worker.execute();

			}
		});
		btnSkipTo.setBounds(248, 133, 113, 23);
		f.getContentPane().add(btnSkipTo);

		JLabel lblHexSize = new JLabel("Hex Size:");
		lblHexSize.setFont(new Font("Calibri", Font.BOLD, 13));
		lblHexSize.setBounds(406, 41, 59, 17);
		f.getContentPane().add(lblHexSize);

		spinnerHexSize = new JSpinner();
		spinnerHexSize.setBounds(475, 39, 44, 20);
		f.getContentPane().add(spinnerHexSize);

		JButton btnSetHex = new JButton("Set Hex");
		btnSetHex.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {

				hexSize = (int) spinnerHexSize.getValue();
				conflictLog.addNewLine("Hex Size Set To " + hexSize);
			}
		});
		btnSetHex.setBounds(406, 70, 89, 23);
		f.getContentPane().add(btnSetHex);

		// System.out.println("Init order size: "+initiativeOrder.size());
		// Opens active unit
		if (initiativeOrder != null && initiativeOrder.size() > 0) {

			// Updates Lavels
			setUnitlabel();
			setRound();
			setPhase();
			setActions();

			if (openUnit) {
				Unit unit = initiativeOrder.get(activeUnit);
				openUnit(unit, activeUnit);
			}

			// System.out.println("Load Active Unit: "+activeUnit);
		}

		if (game.getDaylightCondition().equals(""))
			comboBoxVisibility.setSelectedIndex(0);

		// Creates hex grid
		// System.out.println("Create hex grid");
		this.hexGrid = new HexGrid(initiativeOrder, gameWindow, hexRows, hexCols);
		if (hexGrid != null && hexGrid.panel.deployedUnits.size() > 0) {
			hexGrid.panel.selectedUnit = hexGrid.panel.deployedUnits.get(activeUnit);
		}

		spinnerHexSize.setValue(hexSize);

		JButton btnNewButton_3 = new JButton("CQB Check");
		btnNewButton_3.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				if (currentlyOpenUnit == null) {
					conflictLog.addNewLine(
							"Use this button at the start of a conflict, specifically when some units are begining the conflict in close quarters battle. "
									+ "Open the first unit in the init order to perform a CQB check.");
					return;
				}

				closeQuartersBattleCheck(currentlyOpenUnit);
			}
		});
		btnNewButton_3.setBounds(444, 101, 128, 23);
		f.getContentPane().add(btnNewButton_3);

	}

	// Opens active unit window
	public void openUnit(Unit unit, int index) {
		// System.out.println("Open unit moral: "+unit.moral);

		try {
			if (currentlyOpenUnit != null)
				currentlyOpenUnit.f.dispose();
			currentlyOpenUnit = new OpenUnit(unit, gameWindow, index);
		} catch (Exception e) {
			System.out.println("toString(): " + e.toString());
			System.out.println("getMessage(): " + e.getMessage());
			System.out.println("StackTrace: ");
			e.printStackTrace();
		}

	}

	// Sets companies equal to the comapny in the setup window
	// Used to save changes made to a company during a conflict
	public void confirmCompany(Company company, int index) {
		setupWindow.setCompany(company, index);
		setupWindow.refreshCreated();
	}

	// Refresh conflict
	public void refreshConflict(SetupWindow setupWindow) {
		this.companies = setupWindow.getActivated();
		rollInitiativeOrder();
		refreshInitiativeOrder();
	}

	public void refreshInitiativeOrder() {
		DefaultListModel initiativeOrderList = new DefaultListModel();

		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Loops through troopers in the unit

			for (int x = 0; x < initiativeOrder.get(i).getSize(); x++) {
				Trooper currentTrooper = initiativeOrder.get(i).getTroopers().get(x);
				currentTrooper.number = x + 1;
			}

			initiativeOrderList.addElement(i + ": " + initiativeOrder.get(i));

		}

		listIniativeOrder.setModel(initiativeOrderList);

		setUnitlabel();
		
		if(hexGrid != null) {
			hexGrid.refreshDeployedUnits();
		}
		
	}

	// Loops through companies
	// Adds units to units array
	// Sets units sides, command value, and initiative
	public void setInitiativeOrder(ArrayList<Company> companies) {
		Random rand = new Random();

		initiativeOrder.clear();

		for (int i = 0; i < companies.size(); i++) {
			Company company = companies.get(i);
			ArrayList<Unit> units = company.getUnits();
			for (int j = 0; j < company.getUnitsLength(); j++) {
				Unit unit = units.get(j);
				// Sets some unit stats
				unit.side = company.getSide();
				unit.company = company.getName();
				unit.getCommandValue();
				int roll = rand.nextInt(10) + 1;
				unit.initiative = roll + unit.commandValue;
				if (unit.active) {
					initiativeOrder.add(unit);
				}

			}
		}

		rollInitiativeOrder();

	}

	// Sets initiative order
	public void rollInitiativeOrder() {

		Unit temp;

		for (int i = 0; i < initiativeOrder.size(); i++) {

			for (int j = 0; j < initiativeOrder.size() - 1; j++) {

				if (initiativeOrder.get(j + 1).initiative > initiativeOrder.get(j).initiative) {
					temp = initiativeOrder.get(j + 1);
					initiativeOrder.set(j + 1, initiativeOrder.get(j));
					initiativeOrder.set(j, temp);

				}
			}
		}

		closeCombatCheck();
		// closeQuartersBattleCheck();
	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void nextActiveUnit() {

		conflictLog.addNewLine("Next unit... Active Unit: " + activeUnit);

		int actions = game.getCurrentAction() + 1;

		// Increases passed active unit members by 1
		if (activeUnit > -1) {
			Unit unit = initiativeOrder.get(activeUnit);
			ArrayList<Trooper> troopers = unit.getTroopers();
			for (int j = 0; j < troopers.size(); j++) {

				// Increases time unconscious
				// Checks for wake up
				if (game.getCurrentAction() <= 3 && game.getCurrentAction() != 0) {

					if (!troopers.get(j).conscious) {

						if (troopers.get(j).timeUnconscious == troopers.get(j).incapacitationTime) {
							troopers.get(j).timeUnconscious = 0;
							troopers.get(j).incapacitationTime = 0;
							conflictLog.addNewLine(troopers.get(j).number + " " + troopers.get(j).name + " from unit:"
									+ unit.callsign + "has awoken.");
							troopers.get(j).conscious = true;
						} else {
							troopers.get(j).timeUnconscious++;
						}

					}

				}

				if (game.getPhase() == 1) {
					if (troopers.get(j).spentPhase1 != actions - 1) {

						if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1)
							troopers.get(j).spentPhase1 += 1;
					}
				} else {
					if (troopers.get(j).spentPhase2 != actions - 1) {

						if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2)
							troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			return;
		}

		int size = initiativeOrder.size();
		size--;

		// If next unit is empty
		// Skips next unit
		// System.out.println("Active Unit: "+activeUnit);
		int unitCount = 1;
		boolean pass = false;
		while (!pass) {

			// Makes sure there is a unit infront of the active unit
			if (activeUnit + unitCount != initiativeOrder.size()) {

				// Checks if the next unit is the last one
				if (activeUnit + 2 == initiativeOrder.size()) {
					// Checks if the last unit is empty
					if (initiativeOrder.get(activeUnit + 1).getSize() < 1) {
						activeUnit = size;
						break;
					}
				}

				// Checks if next unit is empty
				// If unit is alive and not empty
				if (initiativeOrder.get(activeUnit + unitCount).getSize() < 1) {
					// System.out.println("Increase");
					unitCount++;
				} else {

					pass = true;
					activeUnit += unitCount;
					activeUnit--;

				}

				/*
				 * if(activeUnit + unitCount > size || activeUnit > size) { activeUnit = size;
				 * break; }
				 */

				// System.out.println("Modified Active Unit: "+activeUnit);

			} else {
				break;
			}

		}

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		endOfInitOrder(size, actions);

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		openUnit(initiativeOrder.get(activeUnit), activeUnit);

		// Updates Labels
		setUnitlabel();
		setRound();
		setPhase();
		setActions();

	}

	// Performs nessesary checks for twenty seconds of passed time
	public void unitWaitTwentySeconds() {

		int actions = game.getCurrentAction();

		Unit unit = initiativeOrder.get(activeUnit);
		int activeTrooperCount = 0;
		int activeTroopersInCover = 0;
		// Forced Route or Pinned
		for (Trooper trooper : unit.getTroopers()) {

			if (trooper.alive && trooper.conscious) {
				activeTrooperCount++;
				if (trooper.inCover)
					activeTroopersInCover++;
			}

		}

		if (unit.suppression >= 50) {

			if ((double) activeTrooperCount / activeTroopersInCover < 0.5) {
				conflictLog.addNewLine(
						unit.callsign + " is forced to route due to high suppression and minimal cover. This "
								+ "unit can avoid routing if all individuals not in cover can hunker down.");
			} else {
				conflictLog.addNewLine(unit.callsign + " is pinned and cannot move until suppression "
						+ "becomes less than 50. Or a successful command test is made, with one difficulty die for every 10 suppression. "
						+ "And 1 bonus die for each additional leader.");
			}

		}

		// Fire Missions
		for (FireMission fireMission : unit.fireMissions) {
			// System.out.println("Calling Advance Time Fire Mission");
			fireMission.advanceTime();
		}

		ArrayList<Trooper> troopers = unit.getTroopers();
		for (int j = 0; j < troopers.size(); j++) {
			// System.out.println("Pass Trooper: "+j);

			if (!troopers.get(j).alive) {
				troopers.get(j).spentPhase1 = troopers.get(j).P1;
				troopers.get(j).spentPhase2 = troopers.get(j).P2;
				continue;
			}

			// Increases time unconscious
			// Checks for wake up
			if (actions <= 3 && actions != 0) {

				if (!troopers.get(j).conscious) {

					if (troopers.get(j).timeUnconscious >= troopers.get(j).incapacitationTime) {
						troopers.get(j).timeUnconscious = 0;
						troopers.get(j).incapacitationTime = 0;
						conflictLog.addNewLineToQueue(troopers.get(j).number + " " + troopers.get(j).name
								+ " from unit:" + unit.callsign + "has awoken.");
						troopers.get(j).conscious = true;

					} else {
						troopers.get(j).timeUnconscious++;
					}
					troopers.get(j).spentPhase1 = troopers.get(j).P1;
					troopers.get(j).spentPhase2 = troopers.get(j).P2;

					continue;

				}

				Trooper trooper = troopers.get(j);
				if (trooper.personalShield != null) {
					PersonalShield ps = trooper.personalShield;

					if (ps.currentShieldStrength < ps.maxShieldStrength) {

						ps.currentShieldStrength += ps.maxShieldStrength * ps.rechargeRate;

						if (ps.currentShieldStrength > ps.maxShieldStrength)
							ps.currentShieldStrength = ps.maxShieldStrength;

					}

				}

			}

			float time;

			if (gameWindow.game.getPhase() == 1) {
				if (troopers.get(j).P1 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P1;
			} else {
				if (troopers.get(j).P2 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P2;
			}

			if (unit.speed.equals("None")) {
				troopers.get(j).fatigueSystem.AddRecoveryTime(time);
			}

			if (game.getPhase() == 1) {
				if (troopers.get(j).spentPhase1 != actions) {

					if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1) {

						// troopers.get(j).spentPhase1 += 1;
					}
				}
			} else {
				if (troopers.get(j).spentPhase2 != actions) {

					if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2) {

						// troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}
	}

	// Performs nessesary checks for twenty seconds of passed time
	public void unitPassTwentySeconds() {

		int actions = game.getCurrentAction();

		Unit unit = initiativeOrder.get(activeUnit);
		int activeTrooperCount = 0;
		int activeTroopersInCover = 0;
		// Forced Route or Pinned
		for (Trooper trooper : unit.getTroopers()) {

			if (trooper.alive && trooper.conscious) {
				activeTrooperCount++;
				if (trooper.inCover)
					activeTroopersInCover++;
			}

		}

		if (unit.suppression >= 50) {

			if ((double) activeTrooperCount / activeTroopersInCover < 0.5) {
				conflictLog.addNewLine(
						unit.callsign + " is forced to route due to high suppression and minimal cover. This "
								+ "unit can avoid routing if all individuals not in cover can hunker down.");
			} else {
				conflictLog.addNewLine(unit.callsign + " is pinned and cannot move until suppression "
						+ "becomes less than 50. Or a successful command test is made, with one difficulty die for every 10 suppression. "
						+ "And 1 bonus die for each additional leader.");
			}

		}

		// Fire Missions
		for (FireMission fireMission : unit.fireMissions) {
			// System.out.println("Calling Advance Time Fire Mission");
			fireMission.advanceTime();
		}

		ArrayList<Trooper> troopers = unit.getTroopers();
		for (int j = 0; j < troopers.size(); j++) {
			// System.out.println("Pass Trooper: "+j);

			if (!troopers.get(j).alive) {
				troopers.get(j).spentPhase1 = troopers.get(j).P1;
				troopers.get(j).spentPhase2 = troopers.get(j).P2;
				continue;
			}

			// Increases time unconscious
			// Checks for wake up
			if (actions <= 3 && actions != 0) {

				if (!troopers.get(j).conscious) {

					if (troopers.get(j).timeUnconscious >= troopers.get(j).incapacitationTime) {
						troopers.get(j).timeUnconscious = 0;
						troopers.get(j).incapacitationTime = 0;
						conflictLog.addNewLineToQueue(troopers.get(j).number + " " + troopers.get(j).name
								+ " from unit:" + unit.callsign + "has awoken.");
						troopers.get(j).conscious = true;

					} else {
						troopers.get(j).timeUnconscious++;
					}
					troopers.get(j).spentPhase1 = troopers.get(j).P1;
					troopers.get(j).spentPhase2 = troopers.get(j).P2;

					continue;

				}

				Trooper trooper = troopers.get(j);
				if (trooper.personalShield != null) {
					PersonalShield ps = trooper.personalShield;

					if (ps.currentShieldStrength < ps.maxShieldStrength) {

						ps.currentShieldStrength += ps.maxShieldStrength * ps.rechargeRate;

						if (ps.currentShieldStrength > ps.maxShieldStrength)
							ps.currentShieldStrength = ps.maxShieldStrength;

					}

				}

			}

			float time;

			if (gameWindow.game.getPhase() == 1) {
				if (troopers.get(j).P1 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P1;
			} else {
				if (troopers.get(j).P2 == 0)
					time = 30;
				else
					time = 60 / troopers.get(j).P2;
			}

			// System.out.println("Pass Add Recovery TIme");
			if (unit.speed.equals("None")) {
				troopers.get(j).fatigueSystem.AddRecoveryTime(time);
			}

			if (game.getPhase() == 1) {
				if (troopers.get(j).spentPhase1 != actions) {

					if (troopers.get(j).spentPhase1 + 1 <= troopers.get(j).P1) {

						troopers.get(j).spentPhase1 += 1;
					}
				}
			} else {
				if (troopers.get(j).spentPhase2 != actions) {

					if (troopers.get(j).spentPhase2 + 1 <= troopers.get(j).P2) {

						troopers.get(j).spentPhase2 += 1;
					}
				}
			}
		}
	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void safeNextActiveUnit() {
		// System.out.println("\n\nCurrent Action: "+game.getCurrentAction()+" Active
		// Unit: "+activeUnit+"\n\n");

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			// System.out.println("Returning Safe Next Active Unit");
			return;
		}

		unitPassTwentySeconds();

		int size = initiativeOrder.size();
		size--;

		/*
		 * activeUnit++; if(activeUnit == initiativeOrder.size()) activeUnit = 0;
		 */

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		// Might contain gui updates
		// System.out.println("Inside Pass1");
		endOfInitOrder(size, game.getCurrentAction() + 1);

		// System.out.println("Inside Pass2");

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		// listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		// System.out.println("Open Next Active Unit");

	}

	// Next active unit
	// Checks for end of actions
	// Checks for end of phase
	public void safeWaitActiveUnit() {
		// System.out.println("\n\nCurrent Action: "+game.getCurrentAction()+" Active
		// Unit: "+activeUnit+"\n\n");

		if (initiativeOrder == null || initiativeOrder.size() < 1) {
			// System.out.println("Returning Safe Next Active Unit");
			return;
		}

		unitWaitTwentySeconds();

		int size = initiativeOrder.size();
		size--;

		/*
		 * activeUnit++; if(activeUnit == initiativeOrder.size()) activeUnit = 0;
		 */

		/*
		 * System.out.println("Next Unit: "+activeUnit+1);
		 * System.out.println("Size: "+size);
		 * System.out.println("Next Unit Size: "+initiativeOrder.get(activeUnit+1).
		 * getSize()); if(initiativeOrder.get(activeUnit+1).getSize() < 1) {
		 * System.out.println("pass"); activeUnit++; }
		 */

		// Checks for end of Initiative Order
		// Might contain gui updates
		// System.out.println("Inside Pass1");
		endOfInitOrder(size, game.getCurrentAction() + 1);
		// System.out.println("Inside Pass2");

		// System.out.println("Post activeUnit: "+activeUnit);

		// Sets next active unit
		// listIniativeOrder.setSelectedIndex(activeUnit);

		// Opens active unit
		// System.out.println("Open Next Active Unit");

	}

	public void guiUpdateNextActiveUnit() {

		conflictLog.addNewLine("Next unit... Active Unit: " + activeUnit);

		// Updates Labels
		setUnitlabel();
		setRound();
		setPhase();
		setActions();

	}

	// Takes a trooper, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public static boolean exhaustedTrooper(Trooper trooper) {
		//System.out.println("Exuasted Trooper test: "+trooper.name);
		if (GameWindow.gameWindow.game.getPhase() == 1) {
			if (trooper.spentPhase1 < trooper.P1) {
				//System.out.println("Return False");
				return false;
			}
		} else {
			if (trooper.spentPhase2 < trooper.P2) {
				//System.out.println("Return False");
				return false;
			}
		}
		
		//System.out.println("Return True");
		return true;
	}

	// Takes a unit, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public static boolean exhaustedUnit(Unit unit) {

		// System.out.println("Entering Exhusted Unit Check");

		
		
		for (Trooper trooper : unit.getTroopers()) {
			if(!exhaustedTrooper(trooper))
				return false; 
		}

		// System.out.println("Returning True");
		return true;
	}
	
	public static boolean mostlyExhausted(Unit unit) {
		
		int exausted = 0, fresh = 0;
		
		for (Trooper trooper : unit.getTroopers()) {
			if(exhaustedTrooper(trooper))
				exausted++;
			else 
				fresh++; 
		}

		if(exausted >= fresh) {
			return true;
		} else {
			return false; 
		}
	}

	public static boolean anyoneExhausted(Unit unit) {
		for (Trooper trooper : unit.getTroopers()) {
			if(exhaustedTrooper(trooper))
				return true; 
		}

		// System.out.println("Returning True");
		return false;
	}
	
	// Returns true if all individuals have spent ap for this action, returns false
	// if they have not
	public boolean checkForAllExahusted() {

		for (Unit unit : initiativeOrder) {
			if (!exhaustedUnit(unit))
				return false;
		}

		return true;
	}

	// Takes a unit, returns true if that unit has spent its AP for this action,
	// returns false if a trooper has not
	public boolean endActionUnit(Unit unit) {

		// System.out.println("Entering End Action Unit Check");

		for (Trooper trooper : unit.getTroopers()) {
			if (game.getPhase() == 1) {
				if (trooper.spentPhase1 < trooper.P1
						&& trooper.spentPhase1 < GameWindow.gameWindow.game.getCurrentAction()) {
					// System.out.println("Returning False");
					return false;
				}
			} else {
				if (trooper.spentPhase2 < trooper.P2
						&& trooper.spentPhase2 < GameWindow.gameWindow.game.getCurrentAction()) {
					// System.out.println("Returning False");
					return false;
				}
			}
		}

		// System.out.println("Returning True");
		return true;
	}

	// Returns true if all individuals have spent ap for this action, returns false
	// if they have not
	public boolean checkForAllEndAction() {

		for (Unit unit : initiativeOrder) {
			if (!endActionUnit(unit))
				return false;
		}

		return true;
	}

	// Checks and performs tasks for the end of the init order
	public void endOfInitOrder(int size, int actions) {

		boolean endOfPhase = checkForAllExahusted();
		boolean endOfAction = checkForAllEndAction();

		if (endOfPhase) {
			conflictLog.addNewLineToQueue("End of Phase");
			// game.setCurrentAction(actions);
			// conflictLog.addNewLineToQueue("Actions: " + actions);
			// Checks for end of phase
			// Loops through units indiviudals

			// Checks for artillery fire missions
			int diff = 3 - game.getCurrentAction();
			//System.out.println("diff: "+diff);
			for(Unit unit : initiativeOrder) {
				// Fire Missions
				for (FireMission fireMission : unit.fireMissions) {
					// System.out.println("Calling Advance Time Fire Mission");
					for(int i = 0; i < diff; i++) {
						fireMission.advanceTime();						
					}
					
				}
			}
			
			// Check for end of round or phase
			if (game.getPhase() == 1) {
				game.setPhase(2);
				// End of phase
				conflictLog.addNewLineToQueue("     Round: " + game.getRound() + " Phase: 2");
				endOfPhase();
			} else {
				game.setPhase(1);
				int round = game.getRound() + 1;
				game.setRound(round);
				conflictLog.addNewLineToQueue("     Round: " + game.getRound() + " Phase: 1");
				// End of round
				endOfPhase();
				endOfRound();

			}

			activeUnit = 0;
		} else if (endOfAction) {
			game.setCurrentAction(actions);
			conflictLog.addNewLineToQueue("End of Action");
			conflictLog.addNewLineToQueue("Actions: " + actions);
			activeUnit = 0;
			
			//System.out.println("End of action");
			
			// Action ended 
			for(DeployedUnit deployedUnit : hexGrid.panel.deployedUnits) {
				deployedUnit.moved = false; 
			}
			
			int currentAction = game.getCurrentAction();
			// Performs spot test
			if (currentAction == 1 || currentAction == 2 || currentAction == 3)
				spotCycle();

		} else if (activeUnit >= size) {

			for (int i = 0; i < initiativeOrder.size(); i++) {

				if (!endActionUnit(initiativeOrder.get(i))) {
					activeUnit = i;
					break;
				}

			}
			
			
			

		} else {
			activeUnit++;
		}
		

	}

	public void closeQuartersBattleCheck(OpenUnit openUnit) {

		cqb.closeQuartersBattleCheck(openUnit);

	}

	// Sets active unit label
	public void setUnitlabel() {
		if (initiativeOrder == null || initiativeOrder.size() < 1)
			return;
		else if (activeUnit > initiativeOrder.size())
			return;
		else if (activeUnit >= initiativeOrder.size()) {
			activeUnit = 0;
			return;
		} else if (initiativeOrder.get(activeUnit) == null)
			return;

		lblActiveUnit.setText("Active Unit: " + initiativeOrder.get(activeUnit).side + "::  "
				+ initiativeOrder.get(activeUnit).callsign);
	}

	// Set round
	public void setRound() {
		lblRound.setText("Round: " + game.getRound());
	}

	// Set phase
	public void setPhase() {
		lblPhase.setText("Phase: " + game.getPhase());

	}

	// Set actions
	public void setActions() {
		lblActions.setText("Actions: " + game.getCurrentAction());
	}

	// End of round
	// Loops through initiative order
	// Resets each troopers spentPhase AP to 0
	// Checks if a trooper is unconscious
	// If the trooper is unconscious increases the time unconscious by two minutes
	// Performs wake up tests is applicable
	public void endOfRound() {
		game.setCurrentAction(1);
		Random rand = new Random();

		// Loops through initiative order order
		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Gets current unit
			Unit unit = initiativeOrder.get(i);

			if (unit.behavior.equals("Recent Contact")) {
				unit.timeSinceContact += 1;

			}

			/*
			 * if(unit.timeSinceContact >= 5) { unit.behavior = "No Contact";
			 * unit.timeSinceContact = 0; }
			 */

			// Gets troopers
			ArrayList<Trooper> troopers = unit.getTroopers();

			// Loops through troopers
			for (int j = 0; j < unit.getSize(); j++) {
				Trooper trooper = troopers.get(j);
				// int TN = trooper.endurance;
				// Resets spent ap
				trooper.spentPhase1 = 0;
				trooper.spentPhase2 = 0;

				// Checks if trooper is conscious
				if (!trooper.conscious) {
					/*
					 * // Increases time spent unconscious trooper.timeUnconscious += 2;
					 * 
					 * // Performs wake up tests
					 * 
					 * 
					 * 
					 * if(trooper.timeUnconscious >= 14 && trooper.currentHP > 0) {
					 * trooper.conscious = true;
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has woken up..."); trooper.timeUnconscious = 0; }
					 * 
					 * 
					 * 
					 * int roll = rand.nextInt(100) + 1;
					 * 
					 * if(trooper.currentHP < -1 * trooper.hp) { if(trooper.timeUnconscious >= 718)
					 * { if(roll > TN) {
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has died of their injuries..."); trooper.alive = false; } } } else
					 * if(trooper.currentHP < 1) { if(trooper.timeUnconscious >= 58) { if(roll <=
					 * TN) {
					 * conflictLog.addNewLine(unit.callsign+":: "+trooper.name+", Number: "+trooper.
					 * number+" has woken up..."); trooper.conscious = true; trooper.timeUnconscious
					 * = 0; } } }
					 */

				}

				// Checks if trooper is mortally wounded
				/*
				 * if(trooper.mortallyWounded) { // Increases time spent mortally wounded
				 * trooper.timeMortallyWounded += 2;
				 * 
				 * // Checks if mortal wound is stabalized, makes rolls once per hour // If the
				 * character is not stablaized then rolls occur every half hour
				 * if(trooper.timeMortallyWounded >= 58 && trooper.stabalized) { int tempTN;
				 * 
				 * int skill = trooper.physicianSkill;
				 * 
				 * if(skill > TN) { tempTN = skill; } else { tempTN = TN; }
				 * 
				 * int roll = rand.nextInt(100) + 1; if(roll > tempTN) { trooper.alive = false;
				 * conflictLog.addNewLineToQueue(unit.callsign+":: "+trooper.name+", Number: "
				 * +trooper.number+" has died of their injuries..."); }
				 * 
				 * } else if(trooper.timeMortallyWounded >= 28) { int roll = rand.nextInt(100) +
				 * 1; if(roll > TN) { trooper.alive = false;
				 * conflictLog.addNewLineToQueue(unit.callsign+":: "+trooper.name+", Number: "
				 * +trooper.number+" has died of their injuries..."); } }
				 * 
				 * }
				 */

			}
		}
	}

	// End of phase

	public void endOfPhase() {

		// Loops through all individuals, increases time passed for wounds
		// Checks unit morale, forces individuals to hunker down that are subject to the
		// morale failure

		for (int i = 0; i < initiativeOrder.size(); i++) {

			for (int x = 0; x < initiativeOrder.get(i).getSize(); x++) {

				if (initiativeOrder.get(i).moral < 30) {
					Random rand = new Random();
					int roll = rand.nextInt(10) + 1;

					if (roll < initiativeOrder.get(i).getTroopers().get(x).P1
							+ initiativeOrder.get(i).getTroopers().get(x).P2) {

						if (initiativeOrder.get(i).getTroopers().get(x).inCover) {
							initiativeOrder.get(i).getTroopers().get(x).HD = true;
							conflictLog.addNewLineToQueue(initiativeOrder.get(i).getTroopers().get(x).number + " "
									+ initiativeOrder.get(i).getTroopers().get(x).name
									+ " hunkers down. Morale too low.");
						}

					}

				}

				initiativeOrder.get(i).getTroopers().get(x).advanceTime(this, conflictLog);
			}

		}

		for (int i = 0; i < initiativeOrder.size(); i++) {
			if (initiativeOrder.get(i).suppression - 10 > 0) {
				initiativeOrder.get(i).suppression -= 5;
			} else {
				initiativeOrder.get(i).suppression = 0;
			}

			if (initiativeOrder.get(i).behavior.equals("No Contact")) {
				initiativeOrder.get(i).organization += initiativeOrder.get(i).commandValue
						+ (initiativeOrder.get(i).moral / 20);
			} else if (initiativeOrder.get(i).behavior.equals("Recent Contact")) {
				initiativeOrder.get(i).organization += initiativeOrder.get(i).commandValue
						+ (initiativeOrder.get(i).moral / 20) / 2;
			}

			if (initiativeOrder.get(i).organization > 100) {

				initiativeOrder.get(i).organization = 100;

			}
		}

		// Loops through initiative order order
		for (int i = 0; i < initiativeOrder.size(); i++) {

			// Gets current unit
			Unit unit = initiativeOrder.get(i);
			// Gets troopers
			ArrayList<Trooper> troopers = unit.getTroopers();

			// Loops through troopers
			for (int j = 0; j < unit.getSize(); j++) {
				Trooper trooper = troopers.get(j);

				// Checks for shields
				// Recharges sheilds
				if (trooper.shields > 0) {
					trooper.currentShields = trooper.shields;
				}

			}

		}

		game.setCurrentAction(1);

	}

	// Loops through each unit
	// Rolls spot for all individuals against units that are not on their side
	public void spotCycle() {

		for (Iterator<Unit> iteratorInitOrder = initiativeOrder.iterator(); iteratorInitOrder.hasNext();) {

			Unit spotterUnit = iteratorInitOrder.next();
			// System.out.println("Spotter Unit: "+spotterUnit);

			for (Iterator<Trooper> troopers = spotterUnit.individuals.iterator(); troopers.hasNext();) {
				Trooper spotterTrooper = troopers.next();
				// System.out.println("Spotter Trooper: "+spotterTrooper.name);
				for (Iterator<Unit> targetUnits = spotterUnit.lineOfSight.iterator(); targetUnits.hasNext();) {

					Unit targetUnit = targetUnits.next();
					// System.out.println("Target Unit: "+targetUnit.callsign);
					// System.out.println("Entering Spot 1");
					spot(targetUnit, spotterUnit, spotterTrooper);
					// System.out.println("Exiting Spot 2");
				}

			}

		}

		/*
		 * for (int i = 0; i < initiativeOrder.size(); i++) { // Gets spotter unit Unit
		 * spotterUnit = initiativeOrder.get(i);
		 * 
		 * // Loops through troopers for(int x = 0; x <
		 * spotterUnit.getTroopers().size(); x++) {
		 * 
		 * // Clears trooper's spot spotterUnit.getTroopers().get(x).spotted.clear();
		 * 
		 * // Loops through units a second time for (int j = 0; j <
		 * initiativeOrder.size(); j++) {
		 * 
		 * // If not the same unit if(!initiativeOrder.get(j).compareTo(spotterUnit) &&
		 * !initiativeOrder.get(j).side.equals(spotterUnit.side)) {
		 * 
		 * 
		 * // Performs spot test spot(initiativeOrder.get(j), spotterUnit,
		 * spotterUnit.getTroopers().get(x));
		 * 
		 * 
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 * 
		 * 
		 * }
		 */

	}

	// Creates new spot action and adds it to trooper
	public void spot(Unit targetUnit, Unit spotterUnit, Trooper trooper) {
		// System.out.println("Target Unit: "+targetUnit.callsign);
		// System.out.println("spotterUnit: "+spotterUnit.callsign);

		for (Unit unit : spotterUnit.lineOfSight) {
			// System.out.println("Unit in LOS: "+unit.callsign);
		}

		// System.out.println("spotterUnitLOS: "+spotterUnit.lineOfSight);
		if (!spotterUnit.lineOfSight.contains(targetUnit)) {
			// System.out.println("No LOS to Units: Spotter Unit: "+spotterUnit.callsign+",
			// targetUnit: "+targetUnit.callsign);
			return;
		}

		// System.out.println("New Spot Action 1");
		Spot spotAction = new Spot(gameWindow, spotterUnit, targetUnit, trooper, "180 Degrees", gameWindow.visibility,
				gameWindow.initiativeOrder, gameWindow);
		// System.out.println("New Spot Action 2");
		// Set results in trooper
		trooper.spotted.add(spotAction);
		// System.out.println("New Spot Action 3");
	}

	// Takes units from companies not already in the init order
	// Makes an init roll
	public void refreshUnits() {

		Random rand = new Random();

		ArrayList<Company> companies = setupWindow.getActivated();

		for (int i = 0; i < companies.size(); i++) {
			Company company = companies.get(i);
			ArrayList<Unit> units = company.getUnits();
			for (int j = 0; j < company.getUnitsLength(); j++) {
				Unit unit = units.get(j);

				boolean alreadyExists = false;
				for (Unit initUnit : initiativeOrder) {
					if (unit.callsign.equals(initUnit.callsign))
						alreadyExists = true;
				}

				if (!alreadyExists) {
					// Sets some unit stats
					unit.side = company.getSide();
					unit.company = company.getName();
					unit.getCommandValue();

					if (game.getPhase() == 1) {
						for (Trooper trooper : unit.getTroopers()) {

							trooper.spentPhase1 = game.getCurrentAction() - 1;

							if (game.getCurrentAction() == 1)
								trooper.spentPhase1 = 0;

						}
					} else {
						for (Trooper trooper : unit.getTroopers()) {

							trooper.spentPhase1 = trooper.P1;
							trooper.spentPhase2 = game.getCurrentAction() - 1;

							if (game.getCurrentAction() == 1)
								trooper.spentPhase2 = 0;

						}
					}

					int roll = rand.nextInt(10) + 1;

					unit.initiative = roll + unit.commandValue;
					if (unit.active) {
						initiativeOrder.add(unit);
					}
				}

			}
		}

		// Removes deactivated units
		/*
		 * for(Unit unit : initiativeOrder) {
		 * 
		 * if(!unit.active) {
		 * 
		 * initiativeOrder.remove(unit);
		 * 
		 * }
		 * 
		 * }
		 */

		// rollInitiativeOrder();
		refreshInitiativeOrder();

	}

	// Loops through all units in the iniiative order, checks if close combat should
	// be initaited
	public void closeCombatCheck() {

		int size = initiativeOrder.size();

		for (int i = 0; i < size; i++) {

			Unit unit = initiativeOrder.get(i);
			boolean closeCombat = false;

			ArrayList<Trooper> flee = new ArrayList<>();
			boolean rout = false;

			for (int x = 0; x < size; x++) {

				Unit unit2 = initiativeOrder.get(x);

				if (!unit.compareTo(unit2)) {

					if (unit.X == unit2.X && unit.Y == unit2.Y && !unit.side.equals(unit2.side)) {
						closeCombat = true;
						Random rand = new Random();

						if (!unit.closeCombat) {
							unit.closeCombat = true;

							if (unit.individuals.size() > 0) {

								int leaderShipRoll = rand.nextInt(100) + 1;

								// System.out.println("LR Roll 1: "+leaderShipRoll);

								if (unit.moral < 60) {
									int margin = 60 - unit.moral;
									margin = margin / 10;
									leaderShipRoll += margin * 10;

								}

								// System.out.println("LR Roll Modded: "+leaderShipRoll);

								gameWindow.conflictLog.addNewLine("Entering Close Combat: " + unit.callsign);
								gameWindow.conflictLog.addNewLine("Command: " + unit.individuals.get(0).command);
								gameWindow.conflictLog.addNewLine("Leadership Roll: " + leaderShipRoll);
								gameWindow.conflictLog.addNewLine("Unit Morale: " + unit.moral);

								if (leaderShipRoll > unit.individuals.get(0).command) {
									for (int j = 0; j < unit.individuals.size(); j++) {
										int roll = rand.nextInt(100) + 1;
										gameWindow.conflictLog.addNewLine(unit.individuals.get(j).name + " "
												+ unit.individuals.get(j).number + " Morale Roll: " + roll);

										if (roll > unit.moral) {
											flee.add(unit.individuals.get(j));
											rout = true;

										}
									}
								}
							}

						}

					}

				}

			}
			if (!closeCombat) {
				unit.closeCombat = false;
			}

			if (rout) {
				unit.flee(gameWindow, unit, flee);
			}

		}

	}

	// Targets X and Y, returns hex
	public Hex findHex(int x, int y) {

		for (Hex hex : hexes) {
			if (hex.xCord == x && hex.yCord == y)
				return hex;
		}

		return null;

	}

	// Finds the differance between the two locations
	public static int hexDif(Unit targetUnit, Unit shooterUnit) {
		return hexDif(targetUnit.X, targetUnit.Y, shooterUnit.X, shooterUnit.Y);
	}

	// Finds the differance between the two locations
	public static int hexDif(int x, int y, Unit shooterUnit) {
		return hexDif(x, y, shooterUnit.X, shooterUnit.Y);
	}

	public static int hexDif(int x, int y, int x1, int y1) {
		return dist(x, y, x1, y1);
	}
	
	public static int dist(int x1, int x2, int y1, int y2) {
		
		int du = x2 - x1;
		int dv = Math.floorDiv(y2 + x2)(y2 + x2 / 2)
		
		
	}
	
	
	public ArrayList<Unit> getUnitsInHex(String sideSpecified, int x, int y) {

		ArrayList<Unit> units = new ArrayList<>();

		for (Unit unit : initiativeOrder) {
			if (unit.X != x || unit.Y != y)
				continue;

			if (unit.side.equals(sideSpecified) || (sideSpecified.equals("") || sideSpecified.equals("None"))) {
				units.add(unit);
			}
		}

		return units;
	}

	public ArrayList<Unit> getUnitsInHexExcludingSide(String sideSpecified, int x, int y) {

		ArrayList<Unit> units = new ArrayList<>();

		for (Unit unit : initiativeOrder) {
			if (unit.X != x || unit.Y != y)
				continue;

			// System.out.println("Add unit");
			if (!unit.side.equals(sideSpecified) || (sideSpecified.equals("") || sideSpecified.equals("None"))) {
				units.add(unit);
			}
		}

		return units;
	}

	public static String getLogHead(Trooper target) {
		return GameWindow.findTrooperUnit(target).callsign + ", " + target.number + ": " + target.name;
	}

	public static void addTrooperEntryToLog(Trooper trooper, String text) {
		GameWindow.gameWindow.conflictLog.addNewLineToQueue(GameWindow.gameWindow.getLogHead(trooper) + " " + text);
	}

	// Loops through units in initiaitive order
	// Looks for unit containing indvididual
	// Returns unit
	public static Unit findTrooperUnit(Trooper trooper) {
		ArrayList<Unit> units = gameWindow.initiativeOrder;

		for (Unit unit : units) {

			for (Trooper trooper1 : unit.getTroopers()) {

				if (trooper1.compareTo(trooper))
					return unit;

			}

		}

		return null;

	}

	public void randomEventCheck() {
		Random rand = new Random();

		if (rand.nextInt(100) + 1 < 5) {
			conflictLog.addNewLine("Random Event Has Occured");
		}

	}

	public void refreshCompanyUnits() {
		// Auto-generated method stub
		conflictLog.addNewLine("Refreshed Units");

		for (Unit unit : initiativeOrder) {

			for (Company company : setupWindow.companies) {

				if (company.getName().equals(unit.company)) {

					for (Unit secondUnit : company.getUnits()) {

						if (secondUnit.callsign.equals(unit.callsign))
							company.getUnits().set(company.getUnits().indexOf(secondUnit), unit);

					}

				}

			}

		}

		setupWindow.refreshCreated();
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-01 11:46:34.309
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-01 11:46:34.309
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2022-10-01 11:59:52.929
!MESSAGE Using unsafe http transport to retrieve http://download.eclipse.org/windowbuilder/latest/artifacts.xml.xz, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2022-10-01 11:59:53.413
!MESSAGE Using unsafe http transport to retrieve http://download.eclipse.org/windowbuilder/latest/content.xml.xz, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.egit.ui 4 0 2022-10-01 12:01:46.525
!MESSAGE https://github.com/xanderBolinger/cffw-java.git: not authorized
!STACK 0
org.eclipse.jgit.api.errors.TransportException: https://github.com/xanderBolinger/cffw-java.git: not authorized
	at org.eclipse.jgit.api.LsRemoteCommand.execute(LsRemoteCommand.java:192)
	at org.eclipse.jgit.api.LsRemoteCommand.call(LsRemoteCommand.java:131)
	at org.eclipse.egit.core.op.ListRemoteOperation.run(ListRemoteOperation.java:116)
	at org.eclipse.egit.ui.internal.components.AsynchronousListOperation.run(AsynchronousListOperation.java:76)
	at org.eclipse.egit.ui.internal.dialogs.CancelableFuture$1.run(CancelableFuture.java:280)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.jgit.errors.TransportException: https://github.com/xanderBolinger/cffw-java.git: not authorized
	at org.eclipse.jgit.transport.TransportHttp.connect(TransportHttp.java:685)
	at org.eclipse.jgit.transport.TransportHttp.openFetch(TransportHttp.java:465)
	at org.eclipse.jgit.api.LsRemoteCommand.execute(LsRemoteCommand.java:170)
	... 5 more

!ENTRY org.eclipse.equinox.security 1 0 2022-10-01 12:02:11.378
!MESSAGE New keyring password generated. 

!ENTRY org.eclipse.egit.ui 4 0 2022-10-01 12:02:14.194
!MESSAGE https://github.com/xanderBolinger/cffw-java.git: not authorized
!STACK 0
org.eclipse.jgit.api.errors.TransportException: https://github.com/xanderBolinger/cffw-java.git: not authorized
	at org.eclipse.jgit.api.LsRemoteCommand.execute(LsRemoteCommand.java:192)
	at org.eclipse.jgit.api.LsRemoteCommand.call(LsRemoteCommand.java:131)
	at org.eclipse.egit.core.op.ListRemoteOperation.run(ListRemoteOperation.java:116)
	at org.eclipse.egit.ui.internal.components.AsynchronousListOperation.run(AsynchronousListOperation.java:76)
	at org.eclipse.egit.ui.internal.dialogs.CancelableFuture$1.run(CancelableFuture.java:280)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.jgit.errors.TransportException: https://github.com/xanderBolinger/cffw-java.git: not authorized
	at org.eclipse.jgit.transport.TransportHttp.connect(TransportHttp.java:685)
	at org.eclipse.jgit.transport.TransportHttp.openFetch(TransportHttp.java:465)
	at org.eclipse.jgit.api.LsRemoteCommand.execute(LsRemoteCommand.java:170)
	... 5 more

!ENTRY org.eclipse.egit.core 4 0 2022-10-01 12:02:43.844
!MESSAGE An exception occurred during push on URI https://github.com/xanderBolinger/cffw-java.git: https://github.com/xanderBolinger/cffw-java.git: not authorized
!STACK 0
org.eclipse.jgit.errors.TransportException: https://github.com/xanderBolinger/cffw-java.git: not authorized
	at org.eclipse.jgit.transport.TransportHttp.connect(TransportHttp.java:685)
	at org.eclipse.jgit.transport.TransportHttp.connect(TransportHttp.java:627)
	at org.eclipse.jgit.transport.TransportHttp.openPush(TransportHttp.java:541)
	at org.eclipse.jgit.transport.PushProcess.execute(PushProcess.java:138)
	at org.eclipse.jgit.transport.Transport.push(Transport.java:1389)
	at org.eclipse.egit.core.op.PushOperation.run(PushOperation.java:254)
	at org.eclipse.egit.ui.internal.push.PushJob.performJob(PushJob.java:86)
	at org.eclipse.egit.ui.internal.jobs.RepositoryJob.run(RepositoryJob.java:59)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.egit.ui 4 0 2022-10-01 12:02:43.845
!MESSAGE Can't connect to any repository: https://github.com/xanderBolinger/cffw-java.git (https://github.com/xanderBolinger/cffw-java.git: not authorized)

!ENTRY org.eclipse.ui 4 0 2022-10-01 16:42:27.839
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4918)
	at org.eclipse.swt.SWT.error(SWT.java:4833)
	at org.eclipse.swt.SWT.error(SWT.java:4804)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:450)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:369)
	at org.eclipse.swt.widgets.Widget.getData(Widget.java:544)
	at org.eclipse.jface.text.source.VisibleLinesTracker.untrack(VisibleLinesTracker.java:117)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.handleDispose(AnnotationRulerColumn.java:499)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.lambda$2(AnnotationRulerColumn.java:278)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:814)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1378)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:428)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.swt.widgets.Display.release(Display.java:3701)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:324)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3250)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:814)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1378)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:428)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.AbstractInformationControlManager.dispose(AbstractInformationControlManager.java:1293)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.dispose(AbstractHoverInformationControlManager.java:919)
	at org.eclipse.jface.text.TextViewerHoverManager.dispose(TextViewerHoverManager.java:367)
	at org.eclipse.jface.text.TextViewer.handleDispose(TextViewer.java:1880)
	at org.eclipse.jface.text.source.SourceViewer.handleDispose(SourceViewer.java:791)
	at org.eclipse.jface.text.source.projection.ProjectionViewer.handleDispose(ProjectionViewer.java:1303)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.handleDispose(JavaSourceViewer.java:460)
	at org.eclipse.jface.text.TextViewer.lambda$1(TextViewer.java:1741)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.StyledText.handleDispose(StyledText.java:6121)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5931)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:814)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:428)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.disposeWidget(SWTPartRenderer.java:183)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.disposeWidget(ContributedPartRenderer.java:286)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:938)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:893)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:113)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:938)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:893)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2087)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1719)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1743)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1743)
	at org.eclipse.ui.internal.Workbench$11.run(Workbench.java:1108)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1091)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1392)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1392)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1368)
	at org.eclipse.ui.internal.Workbench.lambda$16(Workbench.java:2744)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3256)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2022-10-01 16:42:27.841
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4918)
	at org.eclipse.swt.SWT.error(SWT.java:4833)
	at org.eclipse.swt.SWT.error(SWT.java:4804)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:450)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:369)
	at org.eclipse.swt.widgets.Widget.getData(Widget.java:544)
	at org.eclipse.jface.text.source.VisibleLinesTracker.untrack(VisibleLinesTracker.java:117)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.handleDispose(AnnotationRulerColumn.java:499)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.lambda$2(AnnotationRulerColumn.java:278)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:814)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1378)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:428)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.swt.widgets.Display.release(Display.java:3701)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:324)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3250)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:814)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1378)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:428)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.AbstractInformationControlManager.dispose(AbstractInformationControlManager.java:1293)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.dispose(AbstractHoverInformationControlManager.java:919)
	at org.eclipse.jface.text.TextViewerHoverManager.dispose(TextViewerHoverManager.java:367)
	at org.eclipse.jface.text.TextViewer.handleDispose(TextViewer.java:1880)
	at org.eclipse.jface.text.source.SourceViewer.handleDispose(SourceViewer.java:791)
	at org.eclipse.jface.text.source.projection.ProjectionViewer.handleDispose(ProjectionViewer.java:1303)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.handleDispose(JavaSourceViewer.java:460)
	at org.eclipse.jface.text.TextViewer.lambda$1(TextViewer.java:1741)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.StyledText.handleDispose(StyledText.java:6121)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5931)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:814)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:428)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.disposeWidget(SWTPartRenderer.java:183)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.disposeWidget(ContributedPartRenderer.java:286)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:938)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:893)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:113)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:938)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:893)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2087)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1719)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1743)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1743)
	at org.eclipse.ui.internal.Workbench$11.run(Workbench.java:1108)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1091)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1392)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1392)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1368)
	at org.eclipse.ui.internal.Workbench.lambda$16(Workbench.java:2744)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3256)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2022-10-01 16:42:27.844
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4918)
	at org.eclipse.swt.SWT.error(SWT.java:4833)
	at org.eclipse.swt.SWT.error(SWT.java:4804)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:450)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:369)
	at org.eclipse.swt.widgets.Widget.getData(Widget.java:544)
	at org.eclipse.jface.text.source.VisibleLinesTracker.untrack(VisibleLinesTracker.java:117)
	at org.eclipse.jface.text.source.LineNumberRulerColumn.handleDispose(LineNumberRulerColumn.java:649)
	at org.eclipse.jface.text.source.LineNumberChangeRulerColumn.handleDispose(LineNumberChangeRulerColumn.java:333)
	at org.eclipse.jface.text.source.LineNumberRulerColumn.lambda$3(LineNumberRulerColumn.java:618)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:814)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1378)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:428)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.swt.widgets.Display.release(Display.java:3701)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:324)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3250)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:814)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1378)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:428)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.AbstractInformationControlManager.dispose(AbstractInformationControlManager.java:1293)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.dispose(AbstractHoverInformationControlManager.java:919)
	at org.eclipse.jface.text.TextViewerHoverManager.dispose(TextViewerHoverManager.java:367)
	at org.eclipse.jface.text.TextViewer.handleDispose(TextViewer.java:1880)
	at org.eclipse.jface.text.source.SourceViewer.handleDispose(SourceViewer.java:791)
	at org.eclipse.jface.text.source.projection.ProjectionViewer.handleDispose(ProjectionViewer.java:1303)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.handleDispose(JavaSourceViewer.java:460)
	at org.eclipse.jface.text.TextViewer.lambda$1(TextViewer.java:1741)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.StyledText.handleDispose(StyledText.java:6121)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5931)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:814)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:821)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:428)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.disposeWidget(SWTPartRenderer.java:183)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.disposeWidget(ContributedPartRenderer.java:286)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:938)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:893)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:113)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:938)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:893)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2087)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1719)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1743)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1743)
	at org.eclipse.ui.internal.Workbench$11.run(Workbench.java:1108)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1091)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1392)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1392)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1368)
	at org.eclipse.ui.internal.Workbench.lambda$16(Workbench.java:2744)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3256)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-10-01 16:44:30.123 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2022-10-01 16:45:07.896
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2022-10-01 16:45:14.365
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-01 16:45:14.365
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@ba87c11,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@17d19538,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-01 16:45:14.365
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6068cda1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@644e6a8e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.wb.core 4 4 2022-10-01 20:20:36.482
!MESSAGE Designer [1.11.0.202208311516.202210012020]: null argument
!STACK 0
org.eclipse.wb.internal.core.utils.check.AssertionFailedException: null argument
	at org.eclipse.wb.internal.core.utils.check.Assert.fail(Assert.java:225)
	at org.eclipse.wb.internal.core.utils.check.Assert.isNotNull(Assert.java:174)
	at org.eclipse.wb.internal.core.utils.check.Assert.isNotNull(Assert.java:159)
	at org.eclipse.wb.internal.core.utils.ast.AstNodeUtils.getTypeBinding(AstNodeUtils.java:314)
	at org.eclipse.wb.internal.core.utils.ast.AstNodeUtils.getTypeBinding(AstNodeUtils.java:304)
	at org.eclipse.wb.internal.core.utils.ast.AstNodeUtils$4.runObject(AstNodeUtils.java:526)
	at org.eclipse.wb.internal.core.utils.ast.AstNodeUtils$4.runObject(AstNodeUtils.java:1)
	at org.eclipse.wb.internal.core.utils.execution.ExecutionUtils.runObject(ExecutionUtils.java:252)
	at org.eclipse.wb.internal.core.utils.ast.AstNodeUtils.getValue(AstNodeUtils.java:2458)
	at org.eclipse.wb.internal.core.utils.ast.AstNodeUtils.getFullyQualifiedName(AstNodeUtils.java:523)
	at org.eclipse.wb.internal.core.editor.errors.MultipleConstructorsComposite.getConstructors(MultipleConstructorsComposite.java:175)
	at org.eclipse.wb.internal.core.editor.errors.MultipleConstructorsComposite.setException(MultipleConstructorsComposite.java:166)
	at org.eclipse.wb.internal.core.editor.DesignPage.showExceptionOnDesignPane(DesignPage.java:511)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:446)
	at org.eclipse.wb.internal.core.editor.UndoManager.refreshDesignerEditor(UndoManager.java:389)
	at org.eclipse.wb.internal.core.editor.UndoManager.activate(UndoManager.java:90)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState_True(DesignPage.java:275)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState(DesignPage.java:252)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode.showPage(DefaultMultiMode.java:127)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode$1.widgetSelected(DefaultMultiMode.java:63)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:331)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-10-01 20:26:39.789
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:590)
	at org.eclipse.wb.internal.core.model.description.helpers.DescriptionHelper.getIconImage(DescriptionHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getComponentImage(ComponentPresentationHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getFastPresentation(ComponentPresentationHelper.java:139)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getPresentation(ComponentPresentationHelper.java:114)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.preparePresentation(ComponentEntryInfo.java:259)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.initialize(ComponentEntryInfo.java:219)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.getVisualEntry(DesignerPalette.java:267)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette$4.getEntries(DesignerPalette.java:347)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$CategoryFigure.<init>(PaletteComposite.java:368)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$PaletteFigure.refresh(PaletteComposite.java:284)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.refreshPalette(PaletteComposite.java:199)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.setPalette(PaletteComposite.java:192)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.showPalette(DesignerPalette.java:462)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.reloadPalette(DesignerPalette.java:182)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.setInput(DesignerPalette.java:148)
	at org.eclipse.wb.internal.core.editor.JavaDesignComposite.refresh(JavaDesignComposite.java:147)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:604)
	at org.eclipse.wb.internal.core.editor.DesignPage$8$1.run(DesignPage.java:468)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4790)
	at org.eclipse.wb.internal.core.editor.DesignPage$8.run(DesignPage.java:464)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:470)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF_withProgress(DesignPage.java:484)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:432)
	at org.eclipse.wb.internal.core.editor.UndoManager.refreshDesignerEditor(UndoManager.java:389)
	at org.eclipse.wb.internal.core.editor.UndoManager.activate(UndoManager.java:90)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState_True(DesignPage.java:275)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState(DesignPage.java:252)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode.showPage(DefaultMultiMode.java:127)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode$1.widgetSelected(DefaultMultiMode.java:63)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:331)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-10-01 20:36:38.307
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:590)
	at org.eclipse.wb.internal.core.model.description.helpers.DescriptionHelper.getIconImage(DescriptionHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getComponentImage(ComponentPresentationHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getFastPresentation(ComponentPresentationHelper.java:139)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getPresentation(ComponentPresentationHelper.java:114)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.preparePresentation(ComponentEntryInfo.java:259)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.initialize(ComponentEntryInfo.java:219)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.getVisualEntry(DesignerPalette.java:267)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette$4.getEntries(DesignerPalette.java:347)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$CategoryFigure.<init>(PaletteComposite.java:368)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$PaletteFigure.refresh(PaletteComposite.java:284)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.refreshPalette(PaletteComposite.java:199)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.setPalette(PaletteComposite.java:192)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.showPalette(DesignerPalette.java:462)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.reloadPalette(DesignerPalette.java:182)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.setInput(DesignerPalette.java:148)
	at org.eclipse.wb.internal.core.editor.JavaDesignComposite.refresh(JavaDesignComposite.java:147)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:604)
	at org.eclipse.wb.internal.core.editor.DesignPage$8$1.run(DesignPage.java:468)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4790)
	at org.eclipse.wb.internal.core.editor.DesignPage$8.run(DesignPage.java:464)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:470)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF_withProgress(DesignPage.java:484)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:432)
	at org.eclipse.wb.internal.core.editor.UndoManager.refreshDesignerEditor(UndoManager.java:389)
	at org.eclipse.wb.internal.core.editor.UndoManager.activate(UndoManager.java:90)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState_True(DesignPage.java:275)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState(DesignPage.java:252)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode.showPage(DefaultMultiMode.java:127)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode$1.widgetSelected(DefaultMultiMode.java:63)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:331)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-10-01 20:38:12.017
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:590)
	at org.eclipse.wb.internal.core.model.description.helpers.DescriptionHelper.getIconImage(DescriptionHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getComponentImage(ComponentPresentationHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getFastPresentation(ComponentPresentationHelper.java:139)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getPresentation(ComponentPresentationHelper.java:114)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.preparePresentation(ComponentEntryInfo.java:259)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.initialize(ComponentEntryInfo.java:219)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.getVisualEntry(DesignerPalette.java:267)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette$4.getEntries(DesignerPalette.java:347)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$CategoryFigure.<init>(PaletteComposite.java:368)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$PaletteFigure.refresh(PaletteComposite.java:284)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.refreshPalette(PaletteComposite.java:199)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.setPalette(PaletteComposite.java:192)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.showPalette(DesignerPalette.java:462)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.reloadPalette(DesignerPalette.java:182)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.setInput(DesignerPalette.java:148)
	at org.eclipse.wb.internal.core.editor.JavaDesignComposite.refresh(JavaDesignComposite.java:147)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:604)
	at org.eclipse.wb.internal.core.editor.DesignPage$8$1.run(DesignPage.java:468)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4790)
	at org.eclipse.wb.internal.core.editor.DesignPage$8.run(DesignPage.java:464)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:470)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF_withProgress(DesignPage.java:484)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:432)
	at org.eclipse.wb.internal.core.editor.UndoManager.refreshDesignerEditor(UndoManager.java:389)
	at org.eclipse.wb.internal.core.editor.UndoManager.activate(UndoManager.java:90)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState_True(DesignPage.java:275)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState(DesignPage.java:252)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode.showPage(DefaultMultiMode.java:127)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode$1.widgetSelected(DefaultMultiMode.java:63)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:331)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-10-01 20:41:34.886
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:590)
	at org.eclipse.wb.internal.core.model.description.helpers.DescriptionHelper.getIconImage(DescriptionHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getComponentImage(ComponentPresentationHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getFastPresentation(ComponentPresentationHelper.java:139)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getPresentation(ComponentPresentationHelper.java:114)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.preparePresentation(ComponentEntryInfo.java:259)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.initialize(ComponentEntryInfo.java:219)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.getVisualEntry(DesignerPalette.java:267)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette$4.getEntries(DesignerPalette.java:347)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$CategoryFigure.<init>(PaletteComposite.java:368)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$PaletteFigure.refresh(PaletteComposite.java:284)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.refreshPalette(PaletteComposite.java:199)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.setPalette(PaletteComposite.java:192)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.showPalette(DesignerPalette.java:462)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.reloadPalette(DesignerPalette.java:182)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.setInput(DesignerPalette.java:148)
	at org.eclipse.wb.internal.core.editor.JavaDesignComposite.refresh(JavaDesignComposite.java:147)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:604)
	at org.eclipse.wb.internal.core.editor.DesignPage$8$1.run(DesignPage.java:468)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4790)
	at org.eclipse.wb.internal.core.editor.DesignPage$8.run(DesignPage.java:464)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:470)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF_withProgress(DesignPage.java:484)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:432)
	at org.eclipse.wb.internal.core.editor.UndoManager.refreshDesignerEditor(UndoManager.java:389)
	at org.eclipse.wb.internal.core.editor.UndoManager.activate(UndoManager.java:90)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState_True(DesignPage.java:275)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState(DesignPage.java:252)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode.showPage(DefaultMultiMode.java:127)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode$1.widgetSelected(DefaultMultiMode.java:63)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:331)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-10-01 20:44:11.484
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:590)
	at org.eclipse.wb.internal.core.model.description.helpers.DescriptionHelper.getIconImage(DescriptionHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getComponentImage(ComponentPresentationHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getFastPresentation(ComponentPresentationHelper.java:139)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getPresentation(ComponentPresentationHelper.java:114)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.preparePresentation(ComponentEntryInfo.java:259)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.initialize(ComponentEntryInfo.java:219)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.getVisualEntry(DesignerPalette.java:267)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette$4.getEntries(DesignerPalette.java:347)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$CategoryFigure.<init>(PaletteComposite.java:368)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$PaletteFigure.refresh(PaletteComposite.java:284)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.refreshPalette(PaletteComposite.java:199)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.setPalette(PaletteComposite.java:192)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.showPalette(DesignerPalette.java:462)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.reloadPalette(DesignerPalette.java:182)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.setInput(DesignerPalette.java:148)
	at org.eclipse.wb.internal.core.editor.JavaDesignComposite.refresh(JavaDesignComposite.java:147)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:604)
	at org.eclipse.wb.internal.core.editor.DesignPage$8$1.run(DesignPage.java:468)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4790)
	at org.eclipse.wb.internal.core.editor.DesignPage$8.run(DesignPage.java:464)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:470)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF_withProgress(DesignPage.java:484)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:432)
	at org.eclipse.wb.internal.core.editor.UndoManager.refreshDesignerEditor(UndoManager.java:389)
	at org.eclipse.wb.internal.core.editor.UndoManager.activate(UndoManager.java:90)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState_True(DesignPage.java:275)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState(DesignPage.java:252)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode.showPage(DefaultMultiMode.java:127)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode$1.widgetSelected(DefaultMultiMode.java:63)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:331)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-10-01 21:13:28.937
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:590)
	at org.eclipse.wb.internal.core.model.description.helpers.DescriptionHelper.getIconImage(DescriptionHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getComponentImage(ComponentPresentationHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getFastPresentation(ComponentPresentationHelper.java:139)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getPresentation(ComponentPresentationHelper.java:114)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.preparePresentation(ComponentEntryInfo.java:259)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.initialize(ComponentEntryInfo.java:219)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.getVisualEntry(DesignerPalette.java:267)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette$4.getEntries(DesignerPalette.java:347)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$CategoryFigure.<init>(PaletteComposite.java:368)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$PaletteFigure.refresh(PaletteComposite.java:284)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.refreshPalette(PaletteComposite.java:199)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.setPalette(PaletteComposite.java:192)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.showPalette(DesignerPalette.java:462)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.reloadPalette(DesignerPalette.java:182)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.setInput(DesignerPalette.java:148)
	at org.eclipse.wb.internal.core.editor.JavaDesignComposite.refresh(JavaDesignComposite.java:147)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:604)
	at org.eclipse.wb.internal.core.editor.DesignPage$8$1.run(DesignPage.java:468)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4790)
	at org.eclipse.wb.internal.core.editor.DesignPage$8.run(DesignPage.java:464)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:470)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF_withProgress(DesignPage.java:484)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:432)
	at org.eclipse.wb.internal.core.editor.UndoManager.refreshDesignerEditor(UndoManager.java:389)
	at org.eclipse.wb.internal.core.editor.UndoManager.activate(UndoManager.java:90)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState_True(DesignPage.java:275)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState(DesignPage.java:252)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode.showPage(DefaultMultiMode.java:127)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode$1.widgetSelected(DefaultMultiMode.java:63)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:331)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-10-01 21:24:11.088
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:590)
	at org.eclipse.wb.internal.core.model.description.helpers.DescriptionHelper.getIconImage(DescriptionHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getComponentImage(ComponentPresentationHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getFastPresentation(ComponentPresentationHelper.java:139)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getPresentation(ComponentPresentationHelper.java:114)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.preparePresentation(ComponentEntryInfo.java:259)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.initialize(ComponentEntryInfo.java:219)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.getVisualEntry(DesignerPalette.java:267)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette$4.getEntries(DesignerPalette.java:347)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$CategoryFigure.<init>(PaletteComposite.java:368)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$PaletteFigure.refresh(PaletteComposite.java:284)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.refreshPalette(PaletteComposite.java:199)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.setPalette(PaletteComposite.java:192)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.showPalette(DesignerPalette.java:462)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.reloadPalette(DesignerPalette.java:182)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.setInput(DesignerPalette.java:148)
	at org.eclipse.wb.internal.core.editor.JavaDesignComposite.refresh(JavaDesignComposite.java:147)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:604)
	at org.eclipse.wb.internal.core.editor.DesignPage$8$1.run(DesignPage.java:468)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4790)
	at org.eclipse.wb.internal.core.editor.DesignPage$8.run(DesignPage.java:464)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:470)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF_withProgress(DesignPage.java:484)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:432)
	at org.eclipse.wb.internal.core.editor.UndoManager.refreshDesignerEditor(UndoManager.java:389)
	at org.eclipse.wb.internal.core.editor.UndoManager.activate(UndoManager.java:90)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState_True(DesignPage.java:275)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState(DesignPage.java:252)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode.showPage(DefaultMultiMode.java:127)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode$1.widgetSelected(DefaultMultiMode.java:63)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:331)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-10-02 13:00:40.196
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:590)
	at org.eclipse.wb.internal.core.model.description.helpers.DescriptionHelper.getIconImage(DescriptionHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getComponentImage(ComponentPresentationHelper.java:166)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getFastPresentation(ComponentPresentationHelper.java:139)
	at org.eclipse.wb.internal.core.model.description.helpers.ComponentPresentationHelper.getPresentation(ComponentPresentationHelper.java:114)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.preparePresentation(ComponentEntryInfo.java:259)
	at org.eclipse.wb.core.editor.palette.model.entry.ComponentEntryInfo.initialize(ComponentEntryInfo.java:219)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.getVisualEntry(DesignerPalette.java:267)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette$4.getEntries(DesignerPalette.java:347)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$CategoryFigure.<init>(PaletteComposite.java:368)
	at org.eclipse.wb.core.controls.palette.PaletteComposite$PaletteFigure.refresh(PaletteComposite.java:284)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.refreshPalette(PaletteComposite.java:199)
	at org.eclipse.wb.core.controls.palette.PaletteComposite.setPalette(PaletteComposite.java:192)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.showPalette(DesignerPalette.java:462)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.reloadPalette(DesignerPalette.java:182)
	at org.eclipse.wb.internal.core.editor.palette.DesignerPalette.setInput(DesignerPalette.java:148)
	at org.eclipse.wb.internal.core.editor.JavaDesignComposite.refresh(JavaDesignComposite.java:147)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:604)
	at org.eclipse.wb.internal.core.editor.DesignPage$8$1.run(DesignPage.java:468)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4790)
	at org.eclipse.wb.internal.core.editor.DesignPage$8.run(DesignPage.java:464)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:470)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF_withProgress(DesignPage.java:484)
	at org.eclipse.wb.internal.core.editor.DesignPage.internal_refreshGEF(DesignPage.java:432)
	at org.eclipse.wb.internal.core.editor.UndoManager.refreshDesignerEditor(UndoManager.java:389)
	at org.eclipse.wb.internal.core.editor.UndoManager.activate(UndoManager.java:90)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState_True(DesignPage.java:275)
	at org.eclipse.wb.internal.core.editor.DesignPage.handleActiveState(DesignPage.java:252)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode.showPage(DefaultMultiMode.java:127)
	at org.eclipse.wb.internal.core.editor.multi.DefaultMultiMode$1.widgetSelected(DefaultMultiMode.java:63)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:331)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
